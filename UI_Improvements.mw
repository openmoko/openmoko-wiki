==Introduction==

  Obviously the tools are in the wild to build interfaces that could rival
  (or better IMO) anything Apple comes up with. We just need to organize
  this stuff. This would need hardware that can support dynamic
  interfaces. I can help here, too.
  sean@openmoko.com

==Finding inspiration ...==

===Seen Live===

*[http://www.youtube.com/watch?v=89sz8ExZndc Multi-Touchscreen experiments video @youtube]
*[http://www.youtube.com/watch?v=nPqqfVLQ_qY iPhone UI features demo @youtube]
*[http://www.zenzui.com/products.html ZenZui], a [http://en.wikipedia.org/wiki/ZUI ZUI (zooming user interface)]
*[http://labs.live.com/Deepfish/videos.aspx Microsoft Bluefish's ZUI], their new mobile webbrowser
*[http://www.rasterman.com/files/eem.avi EEM], Rasterman's EFL libs on handelds proof of concept

===Clever hacks===

It's been said that having no multitouch screen allows less freedom for innovation. Maybe we could get something out of our touchscreen drivers.

Why ? Think of apple's scroll up/down feature on macbooks touchpads (which '''aren't multi touch''', it's a [http://iscroll2.sourceforge.net/ clever driver hack, iscroll2]):

  To scroll, just place two fingers on your trackpad instead of one. Both fingers
  need to be placed next to each other horizontally (not vertically, the trackpad 
  cannot detect that). Some people get better results with their finger spaced a
  little bit apart, while others prefer having the fingers right next to each other.

  iScroll2 provides two scrolling modes: Linear and circular scrolling.

  For linear scrolling, move the two fingers up/down or left/right in a straight 
  line, respectively, to scroll in that direction.

  Circular scrolling works in a way similar to the iPod's scroll wheel: Move the two
  fingers in a circle to scroll up or down, depending   on whether you move in a 
  clockwise or counterclockwise direction.

Maybe we can port/adapt/get inspiration from this macintosh driver.

===n-D navigation: the polyhedra inspiration===

When we want to navigate files, mp3s in an mp3 player, etc... Every control that the application needs is a button. What about looking at the polyhedrons? We could find one for each usage, with as many surrounding subzones that way be used as controls. Ex: you need 5 buttons, let's take a pentagon with 5 surrounding zones all around. That way, it's always optimized...

http://en.wikipedia.org/wiki/Polyhedra
http://en.wikipedia.org/wiki/List_of_uniform_polyhedra

===Our weapons===

We can't improve the human-machine interface without knowing the strenghts / weaknesses of our hardware; some of the weaknesses might turn out as exploitable features, some strengths as limiting constraints.

====The touchscreen====

Question:

  What exactly does the touchscreen see when  you touch the screen with 2 fingers
  at the same time, when you move them, when you move only one of the 2, etc. I'm 
  also interested in knowing how precise the touchscreen is (ex: refresh rate, 
  possible pressure indication, ...)?

Answer:

* The output is the center of the bounding box of the touched area
* The touch point skips instantly on double touch
* Pressure has almost no effect on a single touch, but not so on a double touch. The relative pressures will cause a significant skewing effect towards the harder touch. You can easily move the pointer along the line between your two fingers by changing the relative pressure.

Conclusions:
* we can detect double touch as jumps, and that's all
* no pressure
* This could be an interesting input method for games - e.g. holding the Neo in landscape view, letting each thumb rest on a specific input area; probably needs to be checked for usability with a real device

Question:

  What does one see when sliding two fingers in parallel up(L,R)->down(L,R)?

Answer:

* In theory you see a slide along the center line between your two fingers. In practice, you can't keep the pressure equal, so you will see some kind of zig-zag line somewhere between the two pressure points in the direction of your slide.

Question:

  What does one see when narrowing two fingers in slide (=zoom effect on iphone)?

Answer:

* In theory you see the pointer stay at the center of the zoom movement. In practice, you can't keep the pressure equal for both fingers, so the pointer will move towards one of the two pressure points.

====Graphics and computational capabilities====

It would be good to report what performance the current hardware allows:
* There was no pure X11 benchmarking done (AFAIK) (how many fps at full VGA scrolling, ex: 1024*480 image scrolling?)
* what about the lcd reactivity? What if we don't see anything but blur while moving items fast?

Please report here your impressions.

==Areas of improvement==

* OpenGL for fluid zooming interfaces (2D: the infinite sphere model, 1D: the infinite wheel of fortune/ribbon model, expos√©)
* HandGestures
* Physics-model based improvements: inertia and friction
* multi touch screen for natural handgestures 
* improved virtual keyboard
* switching to another GUI lib (EFLs)

===Physics-inspired animation===

If we want to add eye candy & usability to the UI (such as smooth realistic list scrolling, as seen in apple's
iphone demo on contacts lists), we'll need a physics engine, so that moves & animations aren't all linear.

The most used technique for calculating trajectories and systems of related geometrical objects seems to be [http://en.wikipedia.org/wiki/Verlet_integration verlet integration] implementation; it is an alternative to Euler's integration method, using fast approximation. 

We may have no need for such a mathematical method at first, but perhaps there are other use cases. For instance, it may be useful to gesture recognition (i'm not aware if existing gesture recognition engines measure speed, acceleration...).

====Libakamaru====

The [http://people.freedesktop.org/~krh/akamaru.git/ akamaru library] is the code behind [http://www.youtube.com/watch?v=VekgyKQoTeM kiba dock]'s fun and dynamic behaviour. It's dependencies are light (needs just GLib). It takes elasticity, friction, gravity into account.

If you want to take a quick look at the code:
svn co http://svn.kiba-dock.org/akamaru/ akamaru

The only (AFAIK) application using this library is kiba-dock, a *fun* app launcher, but we may find another use to it in the future.

As suggested on the mailing list, it is mostly overkill for the uses we intend to have, but this library may be optimized already, the API can spare some time for too. Furthermore, ''Qui peut le plus, peut le moins''.

====Verlet integration implementation from e17====

There's an undergoing verlet integration implementation into the e17 project (by rephorm) see http://rephorm.com/news/tag/physics , so we may see some UI physics integration into e17 someday.

====Robert Pernner's easy equations====

http://www.robertpenner.com/easing/

See the demo: implements non linear behaviour (actionscript), but may give inspiration

===Extending the touchscreen capabilities and input methods===

* '''Multitouchscreen emulation'''

If we got it right, when touching the screen on a second place, the cursor oscillates between the two points depending on relative pressure distribution. Using averaging algorithms, we may have the opportunity to detect peculiar behaviours.

We need raw data (x,y,t) from the real hardware for the following behaviours:
* slide two fingers in parallel - vertical up/down (scroll)
* turn the two fingers around (rotate)
* slide two fingers towards each other (zoom-)
* slide two fingers apart (zoom+)

When touching the screen with two fingers at the same time, we necessarily see the two points, or are able to extrapolate the position of the second one. This solution can add feature, but will probably be little erratic...

* '''Other detectable behaviours'''

The warping can be used in the 4 diagonals, plus the up/down/right/left cross:

  ----------------  ----------------  ----------------  ----------------
  - 1            -  - 1          2 -  - 1            -  -      2       -
  -              -  -              -  -              -  -              -
  -              -  -              -  -              -  -              -
  -              -  -              -  -              -  -              -
  -              -  -              -  -              -  -              -
  -              -  -              -  -              -  -              -
  -             2-  -              -  - 2            -  -      1       -
  ----------------  ----------------  ----------------  ----------------

===Improved virtual keyboard===

We need some sort of T9. When typing a word, the first letter determines the next possible ones. Therefore, we may let disappear the less-probable following letters. Ex: type an L, there's no way an X follows...

Hints: 
* ZIP's huffmann compression applied to SMSs/mails for detecting the most used characters/words/sentences.
* html tag-couds, one-letter tag clouds ; font size proportional to the probability of being used

The most critical point is the initial disposition of the letters, before any letter is typed. We may also want to use horizontal two-parts keyboard (with the neo in hands like a psp..)

===Using [http://www.enlightenment.org/Libraries/Overview/ EFL]-based apps===

As an e17 user for quite some time, i always was astonished by the level of efficiency, elegance and eye-candy without using any fancy compositing X features: e17 will work on ''any'' Xserver. It seems that using GTK+ for the base UI is a problem: slow, sluggish... So, why not using an [http://www.enlightenment.org/Libraries/Overview/ EFL]-based UI?

These libs are quite embedded-oriented, and could be a great match for openmoko. Some people already worked on the subject, having mitigated results, but these libs definetly work on handeld devices.

There are 2 ways to go:
* either port/tune e17 so that it fits into a VGA (640*480) screen, and optimized for finger operation as well as touchscreen
* or develop our own EFL-based UI, such as Rasterman's [http://www.rasterman.com/files/eem.avi EEM] proof of concept

===="Porting" e17====

In fact, i started thinking about this [http://edevelop.org/node/2420 1] [https://lists.gnumonks.org/pipermail/openezx-devel/2006-April/000227.html 2] [http://www.motorolafans.com/MotorolaFansPHPbb/viewtopic.php?t=3585 3] [http://lists.jerryweb.org/pipermail/mkezx/2007-January/000363.html 4] some time ago (2006-04), and some other people might be interested in participating. And some [http://lists.jerryweb.org/pipermail/mkezx/2007-January/000364.html already started], in the mkezx project for instance.

What's to do then?
* tuning the config for the size of the device (compilation options, configuration, small patches about input methods)
* benchmarking
* developing custom modules (ex: GPRS signal)

'''Live examples:'''
* installing e17 on a Zaurus C-860 (VGA screen); the tutorial is very interesting, we can spare a lot of work (hopefully): http://gefechtsdienst.de/uman/Zaurus_C-860/E17_setup/index.html Here's a [http://gefechtsdienst.de/uman/files/zaurus/e17-apply-config.sh script] for automatic e17 parameters applying.
* [http://mail.pdaxrom.org/contrib/daal/ OpenZaurus] has e17 in it's packages.
* [http://www.oesf.org/forums/index.php?showtopic=21930&hl=e17 e17 thread in open embedded forums]

====Rolling our own EFL-based UI====

EEM is a proof of concept: a simple UI showing an app launcher/menu on an embedded device.

Links:
*[http://www.rasterman.com/files/eem-live.avi Filmed video of the demo running an ipaq]
*[http://www.rasterman.com/files/eem.avi Captured video]
*[http://www.rasterman.com/files/eem.tgz Source code]

It has already been partially ported on:
*[http://archive.gp2x.de/cgi-bin/cfiles.cgi?0,0,0,0,46,1647 GP2X]
*[https://svn.jerryweb.org/public/mkezx/trunk/packages/evas/ mkezx]

====The EFL libs====

''In developing DR17 it was made clear that we needed an entirely new set of libraries and tools. Raster had a bold vision of what was possible and where he wanted the next release to go, starting with Imlib2 and EVAS, and eventually growing into new libraries largely based on or around EVAS. It became clear that the usefulness of these libraries and tools went far beyond the DR17 release itself, just as Imlib did in DR16. Thus the collective library back-end of DR17 was given the independent title: the Enlightenment Foundation Libraries, or EFL for short.

The EFL contains solutions for almost any graphical interface task, far beyond just rendering images. '''EVAS provides a highly optimized canvas library'''. Ecore provides a simple and modular abstraction interface and advanced event management including timers. '''Etox provides a complex text layout library complete with theme-able text stylization capabilities (previously Estyle)'''. EDB provides a compact database format for intuitive and easy configuration management, including the storing of binaries. EET provides an integrated and flexible container that ends the traditions of providing themes in tarballs. '''Edje provides a revolutionary library and tool set for completely abstracting application interfaces from their code, including a complex and flexible method of designing interfaces. EWL provides a complete widget library built on all the other components of the EFL'''. And more!''

From: http://www.enlightenment.org/


http://www.rasterman.com/files/efl.png

All descriptions beyond come from http://www.enlightenment.org/Enlightenment/DR17/ .

=====Evas=====

Evas is a very core part of the EFL. It is the rendering and display management engine that sits under anything you see on a screen. It does all the work of managing display objects, their state, state changes, layering, rendering and scaling, image loading, text rendering, update handling, optimizing the display pipeline to avoid work and more. It does a lot of the grunt work of display, and is portable beyond X. '''It even runs in the framebuffer directly without needing X, under Trolltech's Qtopia, on DirectFB, can render into a memory buffer''', and use OpenGL to accelerate rendering. It is extremely flexible and very powerful, saving a lot of time writing repetitive drawing routines that often end up not performing optimally as to do so takes a lot of time, care and effort that most programmers would not want to spend, because it distracts from the important work of making their application.

'''Evas on embedded'''

'''But despite all of the things that Evas can do, it is not very large. It has been kept small and lean to make it viable for use on NOT just heavy-weight desktops, but also on limited resource devices such as PDA's, mobile phones and Smart phones, Stereo systems, DVD Players, PVR/DVR Systems and more. It has already been ported to Mobile phones and PDA's, PVR/DVR systems and has proved itself capable of driving these displays very nicely with beautiful effects.''' The developer does not have to change how they code for a device or their desktop as the API and rendering are the same, so no special development environments or emulators are needed. This saves time and effort, allowing desktop and device code to be shared and maintained easily. Also since Evas hides the details of the devices display format, and virtualizes the display at an object level, the programmer doesn't need to care how to render things. They can use a standard system that is universal across all instances of Evas.

Evas provides alpha blending, high quality scaling of images, anti-aliased truetype text, gradients, lines, polygons and more. The list of supported objects is growing, and can be extended via smart objects. It has an interface mechanism to allow for video data to be efficiently handled (which is what Emotion exploits) and more.

=====Edje=====

Edje is one of the more unique parts of EFL, combining many things that Shockwave / FLASH can do with some things it can't, but instead of being designed as a player, it is designed as a slave library to be used by an application to enhance the applications content and display via external compressed data files. It is being expanded continuously, and thanks to its clean design is easy to improve. This is the theme engine behind Enlightenment 0.17 and beyond and at last formalizes Enlightenment themes in a simple and consistent manner.

A Quick list of its features:

    * Scalable bitmap images
    * Highly compressed in-lined images
    * Lossless and lossy compression with or without alpha channel
    * In-lined compressed truetype fonts
    * Multiple inbuilt font effects
    * Automatic font sizing based on size or area
    * Text compression and ellipsis based cutting
    * Rectangle objects
    * Configurable color scheme system
    * Ability to embed Edje objects within Edje objects
    * Embryo scripting language for complex interactions
    * Sand-boxed scripts so they cannot do much damage
    * Alpha blending
    * Completely scalable and re-sizable layout and interface metrics
    * Completely calculated tweened animation for ultra-smooth display

===Distant future: OpenGL compositing===

Compositing seems to give zooming interfaces reality (at last!).

Well, considering recent changes in destkop applications, opengl has a definite future. For instance, the expose (be it apple's or beryl's) is a very interesting and usable feature. Using compositing allows the physics metaphore: '''the human brain doesn't like "gaps"/jumps (for instance while scrolling a text), it needs continuity''', which can be provided by opengl. When you look at apple's iphone prototype, it's not just eye candy, it's maybe the most natural/human way of navigating, because it's sufficiently
realistic for the brain to forget the non-physical nature of what's inside.

So, opengl hardware will be needed in a more or less distant hardware,
for 100% fluid operation.

How cool will solid-based (polygons, as seen in beryl) interfaces be? :) Real ZUIs...

====Clutter Toolkit====

Clutter, an openedhand project, is an open source software library for creating fast, visually rich graphical user interfaces. The most obvious example of potential usage is in media center type applications. We hope however it can be used for a lot more.

http://clutter-project.org/

Clutter uses OpenGL (and soon optionally '''OpenGL ES''') for rendering but with an API which hides the underlying GL complexity from the developer. The Clutter API is intended to be easy to use, efficient and flexible.

From the [http://en.wikipedia.org/wiki/OpenGL_ES wikipedia article], OpenGL ES (OpenGL for Embedded Systems) is a subset of the OpenGL 3D graphics API designed for embedded devices such as mobile phones, PDAs, and video game consoles.

==Improvement ideas==

Please add here any idea that seems of relevance.

===1D list scrolling: looped physics-driven item list===

====Description====

Take an item list (ex: adress book), print it on a ribbon of paper, and glue it on a wheel (on the tire). You're looking in the front of it, so when you want to go from the A to Z, you touch the wheel and drag it up. When you let the wheel go, it goes furter, taken by it's inertia. Stop the wheel when you got your contact. Got the idea? That's why we may speak of an "infinite wheel", so that the surface is flat. For our case here, we always want to display square content, so the [http://en.wikipedia.org/wiki/Uniform_prism n-sided uniform prism] analogy is mathematically more exact.

Important features:
* '''weight''': the biggest the item list, the faster it scrolls; that way, you don't have to wait too long for big lists, and you don't miss your item on shorter lists
* '''friction''': there is friction where the wheel is fixed, so that the wheel doesn't turn infinitely; more friction on short lists, less on big ones
* the '''initial speed and acceleration vector''' you give it determines it's futher rotation
* it's "round"/cyclic, so you can '''browse the list in two directions'''
* we may want to add a "progression indicator", ex the current alphabetical letter, with a font size adequate to the proportion of the number of entries in the letter subcategory, or a reduced map of the distribution of the first letters...
 
We can add "parallel wheels", symbolizing different sorting methods. Slide long to the left / right to look at a different wheel = items organization.

====Controls====

* Sliding up/down = Single click + maintained for a minimal distance

Effect: scroll in an inverted/negated fashion (slide down = scroll up, slide up = scroll down)

When finger is released (i.e. touchscreen doesn't detect any press):
  if (last_speed_seen > 0 ) then keep this speed and acceleration, with friction
  else stop scrolling

Scrolling here is seen as unidimensional, but can apply to bidimensional situations (ex: zoomed image) too

* Action = quick double tap

* Details/select = short single tap

* Right click = long tap

* Sliding left/right: switch sorting method

====Parts to "hack"====

''Having a scroll that isn't a 1:1 map to the user's action isn't hard. It's just an extra calculation in the scroll code.''

<---- Where is the scroll code? :)

* libmokoui
* gtk

I'm wondering what layer of openmoko has to be hacked, i.e. if working at openmoko layer allows enough possibilities for this; if i'm not mistaken, this is part of libmokoui, but i'm pretty afraid that patching gtk itself woud be needed. Working on the lower level would
apply changes to every application, not only openmoko's.

TODO:
* remove the scrolling slider on finger mode
* make the entire list a "scrolling zone", i.e. an overlay transparent scrolling slider
* define controls
* add the inertia feature

===1D Scrolling: inertia friction integration into openmoko's finger wheel=== 

The same, but for the wheel. It can be very short to do: you don't have 1:1 anymore, but, for example, 1/4 wheel turn = 1 item. It's demultiplicated, but has inertia.

===Handgesture recognition proposals===

====Using simple, localized warp as modifier key====

As discussed on community list:

  If you hold down one finger and tap the other one, the mouse pops over and back
  again. If you keep your second finger touching, the cursor follows it. When you
  release it, cursor goes back to first finger position. This could be a way to
  set a bounding box or turn on the mode. So the second finger can do something
  like rotating around the first, or increase or lower the distance to the first.

* the socalled "first touch" can be done on the mokowheel zone itself: put your left thumb on the black area; if you touch the screen with another finger, there is a '''warp'''; the warp is detectable and allows to enter "fake multitouchscreen mode"
* afterwards,
     * slide your righthand finger down, it scrolls up
     * slide your righthand finger up, it scrolls down
     * slide it left, next page/item
     * slide it right, previous page/item
     * do a circle: rotation
     * narrow towards the black circle: zoom -
     * go away: zoom +
* if you had kept your first finger on the black quartercircle, you can continue issuing other gestures

The advantages of using simple origin-driven cursor warping as double touch detection criteria is that:
* you don't have to use the wheel as button, which would slow things down and generate errors (false button presses)
* simpler detection algorithms that can pass by the fluctuation due to pressure relative distribution
* the space taken by the wheel itself is "useless" (i.e. displays no information); using it as modifier allows to keep the screen clean for reading
* the origin of this zone lets use maximum surface of the screen, allowing more fine controlling

[[Image:Fake_multitouch_rotate_right.png]]

[[Image:Fake_multitouch_scroll_previous.png]]

[[Image:Fake_multitouch_scroll_down.png]]

[[Image:Fake_multitouch_zoom-.png]]

*Pros:
** who said we need multitouch hardware?
** this may be the easiest way (in terms of design/implementation complexity, reliability)
*Cons: 
** no matter what we'll invent, we'll need two hands for on-the-move controlling
** what about left-handeds?

====Full multi-touch emulation====

Doable, but tricky...

==Open questions==

* will the neo/openmoko graphics system be powerful enough for such uses? I suspect apple to do opengl acceleration on this device,
which is waaaaay impossible for us for now
* how does the touchscreen behave? We need a detailed touchscreen wiki information page, with visual traces. How hardware-specific is it?
* without multitouch, is there really room for improvement?
  Obviously, multitouch would'nt allow that many space for innovation
