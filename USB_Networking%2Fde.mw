= Neo1973 - Seite =

== Namensauflösung ==

Standardmäßig hat das Neo1973 eine Netzwerkschnittstelle usb0, die mit einem im Kernel einkompilierten (g_ether) Ethernet Dadget arbeitet.

Wenn Sie auf dem Neo voll qualifizierte Hostnamen im Internet erreichen wollen, müssen sie einen DNS-Server definieren. Dazu erstellen Sie die Datei /etc/resolv.conf, die mindestens diese Zeile enthält:

 nameserver xxx.xxx.xxx.xxx

z.B. nameserver 192.168.1.1

Danach können Sie auf dem Neo Ihre OpenMoko 2007.2 Pakete mit "ipkg update && ipkg upgrade" aktualisieren.

Ein besserer Ansatz ist ein symbolischer Link

 ln -s /var/run/resolv.conf /etc/resolv.conf


Danach erstellen Sie die datei /etc/network/if-up.d/08setupdns, die folgende Zeilen enthält:

 #!/bin/sh -e
 echo  nameserver 192.168.0.200 > /var/run/resolv.conf

Auf diese Weise wird diese Datei vom PPP-Paket korrekt behandelt, wenn eine Einwahl per GPRS stattfindet.


== Routing ==

Sie benötigen eine zusätzliche Route für die Verbindung ins Internet. Diese verbindung kann von Ihrem PC geroutet werden (siehe unten), wenn der PC das Standardrouting-Ziel ist. Sie erreichen dies durch das Hinzufügen von

 gateway 192.168.0.200

zu Ihrer /etc/network/interfaces im Abschnitt usb0.

= Desktop-Seite =

== Manuelle Methode ==

Nach dem Verbinden mit dem Gerät laden Sie das Modul usbnet und konfigurieren Sie die Schnittstelle usb0 (als root):
<pre>
ifconfig usb0 192.168.0.200 netmask 255.255.255.0
</pre>
Wenn Ihre eth0 Schnittstelle sich im selben 'Bereich' (z.B. 192.168.0.105) befinet, dann können Sie folgendes tun:
1. Neo anpingen:
 # ping -I usb0 192.168.0.202
2. Route zum Neo hinzufügen:
 # /sbin/route add -host 192.168.0.202/32 dev usb0
3. Einloggen auf dem Neo:
 # ssh root@192.168.0.202


Wenn Sie keine notwendigen Module zum Erzeugen von usb0 haben, stellen Sie sicher, dass folgende Kernel Optionen aktiviert sind:
* CONFIG_USB_USBNET
* CONFIG_USB_NET_CDCETHER
Beide Optionen sind unter Device Drivers -> USB support -> USB Network Adapters zu finden. Für weitere Informationen siehe [http://www.linux-usb.org/usbnet/ usbnet driver homepage].

== Automatische Methode ==

Die Information entnehmen sie dem [http://blog.haerwu.biz/2007/03/22/hotpluging-usbnet/ Hotplugging usbnet], geschickt von Marcin 'Hrw' Juszkiewicz.


=== Debian oder ähnliche ===
Editieren Sie /etc/network/interfaces wie folgt:
<pre>
allow-hotplug usb0
iface usb0 inet static
        address 192.168.0.200
        netmask 255.255.255.0
        network 192.168.0.0
        post-up iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
        post-up echo 1 > /proc/sys/net/ipv4/ip_forward
        post-up iptables -P FORWARD ACCEPT
</pre>

=== Ubuntu (getestet mit Feisty und Gutsy) ===
Editieren Sie /etc/network/interfaces:
<pre>
auto usb0
iface usb0 inet static
        address 192.168.0.200
        netmask 255.255.255.0
        network 192.168.0.0
        up iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24 &
        up echo 1 > /proc/sys/net/ipv4/ip_forward &
        up iptables -P FORWARD ACCEPT &
        down iptables -D POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24 &
</pre>

Wenn Sie das Kommando "echo 1 > /proc/..." manuell ausführen, könnte sudo nicht ausreichen, denn das Kommando sudo muss unter der Shell bash ausgeführt werden.

Ubuntu Fiesty und Gusty haben offenbahr einen Fehler, dass ifdown nicht ausgeführt wird, solange die Schnittstelle "unplugged" ist. Das bedeutet, dass es nur dann funktioniert, wenn das System neu gebootet wird.

Man kann die Datei /etc/udev/rules.d/85-ifupdown.rules patchen, indem man zwei Zeilen am Ende der Datei editiert:
<pre>
SUBSYSTEM=="net", DRIVERS=="?*", GOTO="net_start"
GOTO="net_end"

LABEL="net_start"

# Bring devices up and down only if they're marked auto.
# Use start-stop-daemon so we don't wait on dhcp
ACTION=="add",          RUN+="/sbin/start-stop-daemon --start --background --pidfile /var/run/network/bogus \
 --startas /sbin/ifup -- --allow auto $env{INTERFACE}"

LABEL="net_end"

ACTION=="remove",       RUN+="/sbin/start-stop-daemon --start --background --pidfile /var/run/network/bogus \ 
 --startas /sbin/ifdown -- --allow auto $env{INTERFACE}"
</pre>

Der Fehler besteht darun, dass LABEL="net_end" an falscher Position steht.

=== openSuSE ===
/etc/sysconfig/network/ifcfg-usb0
 # USB configuration for PDAs (openmoko)
 IPADDR=192.168.0.200
 NETMASK=255.255.255.0
 STARTMODE=onboot

=== Fedora (getestet unter FC8) ===
/etc/sysconfig/network-scripts/ifcfg-usb0
<pre>
# USB configuration for PDAs (openmoko)
# from http://www.handhelds.org/moin/moin.cgi/UsbNet
DEVICE=usb0
BOOTPROTO=none
IPADDR=192.168.0.200
NETMASK=255.255.255.0
ONBOOT=yes
</pre>

=== Red Hat oder ähnliche ===
Editieren Sie /etc/sysconfig/network-scripts/net.hotplug:

Nach diesem Kommando
<pre>
    case $INTERFACE in
	# interfaces that are registered after being "up" (?)
</pre>
fügen Sie hinzu
<pre>
	usb0)
		ifconfig usb0 192.168.0.200 netmask 255.255.255.0
		route add 192.168.0.202 usb0
		iptables -I INPUT 1 -s 192.168.0.202 -j ACCEPT
		iptables -I OUTPUT 1 -s 192.168.0.200 -j ACCEPT
                iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
                echo 1 > /proc/sys/net/ipv4/ip_forward
		exit 0
	;;
</pre>

=== Gentoo ===
* Öffnen Sie /etc/conf.d/net und fügen Sie hinzu:
 # Neo1973
 config_usb0=( "192.168.0.200 netmask 255.255.255.0" )
 routes_usb0=( "192.168.0.202/32 via 192.168.0.200" )
* Erzeugen Sie einen neuen init Script:
 cd /etc/init.d
 ln -s net.lo net.usb0
* Erzeugen Sie iptables Einträge:
 iptables -I INPUT 1 -s 192.168.0.202 -j ACCEPT
 iptables -I OUTPUT 1 -s 192.168.0.200 -j ACCEPT
 iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
* Speichern Sie das
 /etc/init.d/iptables save
* Wenn Sie möchten, dass Routing standardmäßig aktiviert wird:
 rc-update add iptables default

=== MacOS X ===
Sehen Sie [[MacOS_X#USB_Networking|USB Netzwerk Abschnitt im MacOS X Artikel]].

= Mobile Entwicklung  =

== Weiterleiten der DNS Anfragen ==

Wenn Sie Ihren Standort oft wechseln und somit Verbindung zu mehreren Netzwerken haten und Ihre IP Adresse über DHCP beziehen, ist es ziemlich aufwendig, jedes mal die Datei /etc/resolv.conf zu aktualisieren.

Um dies als Teil eines Setup-Scriptes zu tun, kann man einen Proxy DNS einrichten, der auf die IP Adresse des Neo zeigt. Dies bedeutet, dass die Datei /etc/resolv.conf auf dem Neo nur folgendes enthält:

 nameserver 192.168.0.200 

und z.B. der Notebook funktioniert als DNS Proxy und leitet alle Anfragen basierend auf seiner /etc/resolv.conf weiter.

'''Starten Sie den DNS Proxy nur auf der Schnittstelle usb0, um andere Netzwerkverbindungen nicht zu unterbrechen.'''

=== Weiterleiten mit dnrd ===

The script is designed to use [http://dnrd.sourceforge.net/ dnrd] as the dns proxy. The [http://buildhost.automated.it/gta01 script] and a copy of [http://buildhost.automated.it/dnrd-2.20.3.tar.gz dnrd] are available from my site. The script also performs the initial setup of the connection as per the [[USB_Networking#Manual_method]] above.

Der Script ist für die Nutzung von [http://dnrd.sourceforge.net/ dnrd] als DNS Proxy entwickelt. Der [http://buildhost.automated.it/gta01 Script] ist eine Kopie von [http://buildhost.automated.it/dnrd-2.20.3.tar.gz dnrd]. Der Script führt auch die Ersteinrichtung für die Verbindung mit [[USB_Networking/de#Manuelle_Methode]] oben.

=== Weiterleiten mit einem UDP-Forwarder ===

Eine weitere einfache Installation ist mit einem UDP-Forwarder von http://www.tapor.com/udpf/ mit dem folgenden Kommando möglich:

 udpf-elf\
        -p=53\
        -f=`cat /etc/resolv.conf|awk '$1 == "nameserver"{print $2; exit(0);}'`:53

=== Weiterleitung mit Iptables ===
Es ist möglich DNS Anfragen mit Iptables und DNAT weiterzuleiten:

 iptables -t nat -A PREROUTING -p tcp -s 192.168.0.202 -d 192.168.0.200 --dport domain -j DNAT --to-destination 192.168.0.1
 iptables -t nat -A PREROUTING -p udp -s 192.168.0.202 -d 192.168.0.200 --dport domain -j DNAT --to-destination 192.168.0.1

Dabei ist <tt>192.168.0.1</tt> die IP Adresse des Heimatgateways (Routers). Dies ist die einfachste Methode, aber sie ist nicht empfehlenswert, wenn Sie eine direkte Verbindung zum Internet haben und die DNS Server ihres ISP ändern können. Außerdem hat diese Methode keine Lastverteilung.

= Verbindung mit dem Telefon =

Zum Anmelden am Neo <tt>ssh root@192.168.0.202</tt> mit dem leeren root Passwort

Notiz: Der SSH Daeomon (dropbear 0.49) im OpenMoko scheint einen Bug beim Zurückgeben des Verbindungsstatus an den Client zu haben. Ab und zu bekommen sie einen Rückgabewert 255.

===SSH Extras===

Wenn Sie nicht mehr root@192.168.0.202 auf dem PC eintippen möchten, können sie einen Eintrag in der /etc/hosts machen:

 192.168.0.202 neo

dann editieren Sie ~/.ssh/config (oder erzeugen sie) und fügen hinzu

 host neo
 user root

dann brauchen Sie nur einzutippen:

 # ssh neo

Um zu vermeiden, dass SSH für jeden Host eine Zeile mit dem Host-Key in der Datei known_hosts einfügr, können Sie folgende Zeile in der ~/.ssh/config einfügen

  UserKnownHostsFile /dev/null

Vielleicht möchten Sie einen Schlüssel zur Umgehung der Anzeige des Anmeldebildschirms nutzen.

===SSH Schlüssel===
====Vom Host zum Neo====






<span id="bottom"></span> 
{{Languages|USB Networking}}

[[Category:Hardware]]
[[Category:Implemented]]
