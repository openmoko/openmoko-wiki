== Overview ==
=== What is gsmd ===
'''Gsmd''' is a daemon that handles the communication between applications and GSM modem.
Applications control gsmd through '''libgsmd'''. 
libgsmd communicates with gsmd through unix socket, and modem goes through Uart.
The diagram is as following.

http://lh6.google.com/ticktock35/RwDCAWdUPEI/AAAAAAAAAD4/wBrRLv-1oyE/s400/gsmd_overview.jpg

== Gsmd ==
GSMD is a event driven daemon. Each event shall has a response. 
Every event will pass through the '''gsmd_select_main()''' in which finding and executing their correspond call back functions.

The last part of gsmd '''main''' function enters a infinite loop, trying to call '''gsmd_select_main'''.

 while(1) {
          int ret = gsmd_select_main();
          ...
  }

=== gsmd_select_main() ===
gsmd_select_main this is core of the call back function scheme. All devices, gsmd monitors, are described as a struct '''gsmd_fd''', and gsmd_select_main will [http://swoolley.org/man.cgi/select select] them. 
Once an event comes out from one of the devices, gsmd_select_main will try to call it's '''call back function''' that devices registered.

 int gsmd_select_main()
 {
        struct gsmd_fd *ufd, *ufd2;
        fd_set readset, writeset, exceptset;
        int i;
 
        FD_ZERO(&readset);
        FD_ZERO(&writeset);
        FD_ZERO(&exceptset);
 
        /* prepare read and write fdsets */
        llist_for_each_entry(ufd, &gsmd_fds, list) {
                if (ufd->when & GSMD_FD_READ)
                        FD_SET(ufd->fd, &readset);
 
                if (ufd->when & GSMD_FD_WRITE)
                        FD_SET(ufd->fd, &writeset);
 
                if (ufd->when & GSMD_FD_EXCEPT)
                        FD_SET(ufd->fd, &exceptset);
        }
 
        '''i = select(maxfd+1, &readset, &writeset, &exceptset, NULL);'''
        if (i > 0) {
                /* call registered callback functions */
                llist_for_each_entry_safe(ufd, ufd2, &gsmd_fds, list) {
                        int flags = 0;
 
                        if (FD_ISSET(ufd->fd, &readset))
                                flags |= GSMD_FD_READ;
 
                        if (FD_ISSET(ufd->fd, &writeset))
                                flags |= GSMD_FD_WRITE;
  
                        if (FD_ISSET(ufd->fd, &exceptset))
                                flags |= GSMD_FD_EXCEPT;
 
                        if (flags)
                               ''' ufd->cb(ufd->fd, flags, ufd->data);'''
                }
        }
        return i;
 }


==== gsmd_fd ==== 
 struct gsmd_fd {
     struct llist_head list;
     int fd;                         /* file descriptor */
     unsigned int when;
     '''int (*cb)(int fd, unsigned int what, void *data);'''
     void *data;                     /* void * to pass to callback */
 };

When there are anything change in fd, the gsmd_select_main will detect them and try to call it's call back function cb.

That means if you redirect the cb to another implementation, the gsmd will behave very differently.

==== gsmd_atcmd ====
 struct gsmd_atcmd {
        '''struct llist_head list;'''
        void *ctx;
        '''int (*cb)(struct gsmd_atcmd *cmd, void *ctx, char *resp);'''
        char *resp;
        int32_t ret;
        u_int32_t buflen;
        u_int16_t id;
        u_int8_t flags;
        char *cur;
        char buf[];
 };

=== call back functions ===
Gsmd will open two devices. One is uart to modem and the other is the Unix socket, communicating with libgsmd. 

The default call back function of uart (to modem) is ml_parse, in which dealing with writing AT command, and reading response or notifications from modem.
 
==== ml_parse ====
ml_parse is the call back function that handles:
* Initial GSM Modem
* handle correspond AT command call back
* handle notification call back

===== initial GSM Modem =====
When the modem firmware is ready to initial, it will send '''AT-Command Interpreter ready''' to gsmd. If ml_parse get this string, gsmd will try to initialize the modem.
        if (strlen(buf) == 0 ||
            !strcmp(buf, "AT-Command Interpreter ready")) {
                g->interpreter_ready = 1;
                gsmd_initsettings(g);
                gmsd_alive_start(g);
                return 0;
        }
What modem write to gsmd will put in "buf". And if the contents of the "buf" is "AT-Command Interpreter ready" the automatic gsmd initialize will start.

==== atcmd_select_cb ====

===== atcmd_fill =====

===== atcmd_submit =====

== libgsmd ==
== libgsmd-tool ==
== To-do ==
