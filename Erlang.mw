== Introduction ==
'''Erlang''' is a programming language which has many features more commonly associated with an operating system than with a programming language: concurrent processes, scheduling, memory management, distribution, networking, etc.

=== Concurrency ===
- Erlang has extremely lightweight processes whose memory requirements can vary dynamically. Processes have no shared memory and communicate by asynchronous message passing. Erlang supports applications with very large numbers of concurrent processes. No requirements for concurrency are placed on the host operating system.

=== Distribution ===
- Erlang is designed to be run in a distributed environment. An Erlang virtual machine is called an Erlang node. A distributed Erlang system is a network of Erlang nodes (typically one per processor). An Erlang node can create parallel processes running on other nodes, which perhaps use other operating systems. Processes residing on different nodes communicate in exactly the same was as processes residing on the same node.

=== Robustness ===
- Erlang has various error detection primitives which can be used to structure fault-tolerant systems. For example, processes can monitor the status and activities of other processes, even if these processes are executing on other nodes. Processes in a distributed system can be configured to fail-over to other nodes in case of failures and automatically migrate back to recovered nodes.

=== Soft real-time ===
- Erlang supports programming "soft" real-time systems, which require response times in the order of milliseconds. Long garbage collection delays in such systems are unacceptable, so Erlang uses incremental garbage collection techniques.

=== Hot code upgrade ===
- Many systems cannot be stopped for software maintenance. Erlang allows program code to be changed in a running system. Old code can be phased out and replaced by new code. During the transition, both old code and new code can coexist. It is thus possible to install bug fixes and upgrades in a running system without disturbing its operation.

=== Incremental code loading ===
- Users can control in detail how code is loaded. In embedded systems, all code is usually loaded at boot time. In development systems, code is loaded when it is needed, even when the system is running. If testing uncovers bugs, only the buggy code need be replaced.

=== External interfaces ===
- Erlang processes communicate with the outside world using the same message passing mechanism as used between Erlang processes. This mechanism is used for communication with the host operating system and for interaction with programs written in other languages. If required for reasons of efficiency, a special version of this concept allows e.g. C programs to be directly linked into the Erlang runtime system.

=== Fast and Lean ===
- Erlang is fast and lean. A general erlang application has lots of processes. If you are used to OOP you can compare a process with an object. One process per object instance. To make sure the neo could cope with this I watched top while I was busy dialing a phone number on the Aphasia dialer. Each of the twelve buttons are a separate process. Each have its own little animation, and if you look carefully you can see they run in parallell and are acting independent of each other. The top statistics show a really low CPU utilization, I have to dial quite fast to exceed 5% CPU. Next test I made was to measure the time it takes to start these 12 processes and have them display themselves on the screen (aka start the dialer app). It takes approximately 0.5 sec!<br>

[[Image:Dialer.gif]]

== Installation on FSO distribution ==

The minimal erlang system is only 4 MB. It fits nicely into whats left in the neo1973 after openmoko-fso-image-glibc is installed. However, as I am building a vertical application on Openmoko I would prefere to use openmoko-fso-console-image as a baseline and add Xorg and erlang to make a clean environment. Until I have found out how to do that I run the fso-image-glibc and disable e-wm et al.

=== Install erlang ===
Download cean_installer.bin from CEAN http://cean.process-one.net/downloads/ At the CEAN Downloads page, select "Installer" and "Production" and "Linux ARMEL" and Download.  Copy the file cean_installer.bin to your neo. To save keystrokes I have added "192.168.0.202 phone" to my /etc/hosts file.

<pre>
scp cean_installer.bin  phone:/home/root
</pre>

Open a terminal window to the phone. Password is blank. Unless you changed it to something you just have to press enter at the prompt.

<pre>
ssh phone
</pre>

Before you can install erlang you have to get a copy of the file libsctp.so.1. I grabbed one from my Debian installation on the cf card at /media/mmcblk0p2/usr/lib/

<pre>
cp /media/mmcblk0p2/usr/lib/libsctp.so.1 /usr/lib
</pre>

Now you are ready to install erlang
<pre>
chmod 777 cean_installer.bin
./cean_installer.bin
</pre>

If all goes well you will see the erlang console prompt

<pre>
Erlang (BEAM) emulator version 5.6.3 [source] [async-threads:0] [kernel-poll:false]

Eshell V5.6.3  (abort with ^G)
1>
</pre>

I use  ^C and then "a" to exit the shell.

=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]
Download from http://projects.openmoko.org/frs/?group_id=59 It is sufficient if you take the file at http://projects.openmoko.org/frs/download.php/437/ex11lib.zip and unzip it in your source directory.

In file /home/root/.profile

<pre>
export DISPLAY=:0
</pre>

In file /home/root/.erlang

<pre>
io:format("Running Erlang from root~n").
code:add_patha("/home/root/trunk").
</pre>

I keep my erlang source in /home/root/trunk

Copy Xauthority from host

<pre>
scp .Xauthority phone:/home/root
</pre>

When everything is installed you can try this "hello World" code to verify the platform. It will create an empty window.
<pre>
-module(test).
-export([start/0]).
-import(ex11_lib,[eMapWindow/1,xDo/2,xFlush/1,xColor/2,xCreateSimpleWindow/7]).
-include("ex11_lib.hrl").
-define (WT,480).
-define (HT,640).

start() -> spawn(fun win/0).

win() ->
{ok, Display} = ex11_lib:xStart("3.1"),
Win = xCreateSimpleWindow(Display,0,0,?WT,?HT,?XC_arrow,xColor(Display,?blue)),
xDo(Display, eMapWindow(Win)),
xFlush(Display),
loop().

loop() ->
receive
Any -> io:format("Unknown Event~p~n",[Any]), loop()
end.
</pre>
Put this code in a file named test.erl Start erlang console

<pre>
./cean/start.sh
</pre>

and compile and run the file with
<pre>
c(test).
test:start().
</pre>

Note that it is ok to create and compile the file on your host and copy the compiled file "test.beam" to the phone. If you want to compile on the phone you have to install the compiler. Try this in the erlang shell.

<pre>
cean:install(compiler).
</pre>

I must admit that for some reason it doesn't work for me. I don't compile on the phone anyway so it's no big deal.

== Installation on Debian distribution ==

Make sure you have an uboot that is [http://wiki.openmoko.org/wiki/Flashing_the_Neo_FreeRunner#Flashing_the_boot_loader_to_the_NAND compatible], I used Uboot u-boot-gta01bv4-1.2.0+svnnow-r13_0_2632_0.bin

Install Debian, install script is here http://wiki.openmoko.org/wiki/Debian

Follow the instructions. I had to type in the setenv string and then saveenv.
Reboot to get the new menu_4 title to show up.

=== Install erlang ===
<pre>
apt-get install erlang-base
</pre>

=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]

Download from http://projects.openmoko.org/frs/?group_id=59 It is sufficient if you take the file at http://projects.openmoko.org/frs/download.php/437/ex11lib.zip and unzip it in your source directory.

In home directory file .profile
<pre>
export DISPLAY=:0
</pre>
Remove "-nolisten tcp" from /etc/X11/xinit/xservrrc

Install xauth package and create .Xauthority file
<pre>
debian-gta01:~# apt-get install xauth
debian-gta01:~# xauth
xauth:  creating new authority file /root/.Xauthority
Using authority file /root/.Xauthority
xauth> q
</pre>
Copy .Xauthority to /


When everything is installed you can try this "hello World" code to verify the platform. It will create an empty window.
<pre>
-module(test).
-export([start/0]).
-import(ex11_lib,[eMapWindow/1,xDo/2,xFlush/1,xColor/2,xCreateSimpleWindow/7]).
-include("ex11_lib.hrl").
-define (WT,480).
-define (HT,640).

start() -> spawn(fun win/0).

win() ->
{ok, Display} = ex11_lib:xStart("3.1"),
Win = xCreateSimpleWindow(Display,0,0,?WT,?HT,?XC_arrow,xColor(Display,?blue)),
xDo(Display, eMapWindow(Win)),
xFlush(Display),
loop().

loop() ->
receive
Any -> io:format("Unknown Event~p~n",[Any]), loop()
end.
</pre>
Put this code in a file named test.erl Compile the file with
<pre>
erlc test.erl
</pre>
Run from erlang console.
<pre>
erl
test:start().
</pre>

== Erlang development environment ==
You can in fact choose any text editor, and use a terminal window to compile and copy compiled erlang beam-files to the phone. However, I have found SciTE to be a nice choice. It has erlang colour coding, bracket matching, code completion and lots of more stuff you are accustomed to find in a programmers editor. And it's easily configurable to handle compilation and error tracking, click on an error message to go to the line where the error is located.

In addition to all this you can set it up to let you run your erlang app on the host, and to copy the compiled app to the phone and run it there. All from within SciTE. This gives a very fast turnaround time, I can compile my app - run on host - copy to neo - run on neo in less than a minute. Part of this fast development cycle is of course due to the fact that erlang is platform agnostic - the same compiled code runs on Arm and Intel Linux and Windows.

=== Install SciTE ===
Download from here http://www.scintilla.org/SciTE.html and install.

=== Seting up SciTE for openmoko development ===
Before you start configuring SciTE, make sure ssh, scp and rsh works from a terminal window.
I have to run this script whenever I connect the neo to the host
<pre>
#!/bin/bash
ifconfig usb0 192.168.0.200 netmask 255.255.255.0
/sbin/route add -host 192.168.0.202/32 dev usb0
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
iptables -P FORWARD ACCEPT
</pre>

Start SciTE and select menu Options|Open Global Options and uncomment
<pre>
#Erlang|erl||\
</pre>
and at other lines where erlang is a comment. You may have to start SciTE as root to do this.

Create a file named SciTE.properties in your erlang source directory.
<pre>
# SciTE.properties is the per directory local options file and can be used to
# override settings made in SciTEGlobal.properties, SciTEUser.properties and
# SciTEDirectory.properties.
command.subsystem.1.*.erl=0
command.name.1.*.erl=svn update
command.1.*.erl= svn update $(FileNameExt)
command.name.2.*.erl= svn ci
command.2.*.erl= svn ci -m '$(4)' $(FileNameExt)
command.name.3.*.erl=svn co
command.3.*.erl= svn co $(4)
command.name.4.*.erl=svn status
command.4.*.erl= svn status
command.name.5.*.erl=erl evaluate
command.5.*.erl= erl -eval '$(CurrentSelection)' -noshell -s init stop
command.subsystem.6.*.erl=0
command.name.6.*.erl=copy to neo1973
#command.6.*.erl= scp $(FileName).beam   phone:/root/erlang/trunk/ #Debian
command.6.*.erl= scp $(FileName).beam   phone:/home/root/trunk/
command.subsystem.7.*.erl=0
command.name.7.*.erl=add to subversion
command.7.*.erl= svn add $(FileNameExt)
command.subsystem.8.*.erl=0
command.name.8.*.erl=stop X
command.8.*.erl= rsh root@192.168.0.202 /etc/init.d/xserver-nodm stop
#command.8.*.erl= rsh root@192.168.0.202 /etc/init.d/zhone-session stop #Debian
command.subsystem.9.*.erl=0
command.name.9.*.erl=start
command.9.*.erl= rsh root@192.168.0.202 /etc/init.d/xserver-nodm start
#command.9.*.erl= rsh root@192.168.0.202 /etc/init.d/zhone-session start #Debian
</pre>

I am developing a vertical market product based on Openmoko, so I want my erlang platform alone to run (no window manager or Zhone) when the phone is switched on.

Move /etc/X11/Xsession.d/90xXWindowManager away from its current directory.

<pre>
cd /etc/X11/Xsession.d
mv 90xXWindowManager ..
</pre>

This is my /etc/X11/Xsession.d/80zhone. I keep my erlang beam files at /home/root/trunk.

<pre>
#!/bin/sh -e
#zhone > /tmp/zhone.log 2>&1 &
/home/root/cean/start.sh -noshell -pa /home/root/trunk -s main start > debug.txt
renice -3 $!
exit 0
</pre>



For Debian users it's /usr/bin/zhone-session. I keep my erlang beam files at /root/erlang/trunk
<pre>
#zhone &
#matchbox-keyboard-toggle &
erl -noshell -pa /root/erlang/trunk -s main start > debug.txt
#exec matchbox-window-manager -use_titlebar no
</pre>


Replace "-s main start" with "-s your_module_name your_function_name"


All I have to do now is to re-start X whenever I want to run an uploaded app. This is what the last two menu buttons do in SciTe - stop X on the phone, and start X on the phone.
[[Image:Scite.jpg]]

The svn xxx menu items is for version control if you are [[Using Subversion]].

Type
<pre>
ssh phone
</pre>
to get a terminal window and type
<pre>
tail -f /debug.txt
</pre>
to read shell printout from the erlang process.

== Example Code ==
=== Use [[D-Bus]] in erlang ===
<pre>
Dbus = open_port({spawn,"mdbus -s"}, [stream, use_stdio, binary]),
loop(Dbus).
</pre>
And get the response
<pre>
loop(Dbus) ->
receive
{Dbus,Msg} -> io:format("Dbus msg:~p~n",[Msg]),loop(Dbus)
end.
</pre>

== Graphics ==

=== Drawing a widget in AutoCAD LT ===

Screencast [http://www.kvamme.se/Aphasia/Erlang_files/mokobattery.mov here]

=== Convert drawing to erlang source ===

Screencast [http://www.kvamme.se/Aphasia/Erlang_files/battery.mov here]

Take dxf2erl.erl from [http://projects.openmoko.org/frs/?group_id=59 here]

[[Category:Application Developer]]
