== Introduction ==
'''Erlang''' is a programming language which has many features more commonly associated with an operating system than with a programming language: concurrent processes, scheduling, memory management, distribution, networking, etc.

=== Concurrency ===
- Erlang has extremely lightweight processes whose memory requirements can vary dynamically. Processes have no shared memory and communicate by asynchronous message passing. Erlang supports applications with very large numbers of concurrent processes. No requirements for concurrency are placed on the host operating system.

=== Distribution ===
- Erlang is designed to be run in a distributed environment. An Erlang virtual machine is called an Erlang node. A distributed Erlang system is a network of Erlang nodes (typically one per processor). An Erlang node can create parallel processes running on other nodes, which perhaps use other operating systems. Processes residing on different nodes communicate in exactly the same was as processes residing on the same node.

=== Robustness ===
- Erlang has various error detection primitives which can be used to structure fault-tolerant systems. For example, processes can monitor the status and activities of other processes, even if these processes are executing on other nodes. Processes in a distributed system can be configured to fail-over to other nodes in case of failures and automatically migrate back to recovered nodes.

=== Soft real-time ===
- Erlang supports programming "soft" real-time systems, which require response times in the order of milliseconds. Long garbage collection delays in such systems are unacceptable, so Erlang uses incremental garbage collection techniques.

=== Hot code upgrade ===
- Many systems cannot be stopped for software maintenance. Erlang allows program code to be changed in a running system. Old code can be phased out and replaced by new code. During the transition, both old code and new code can coexist. It is thus possible to install bug fixes and upgrades in a running system without disturbing its operation.

=== Incremental code loading ===
- Users can control in detail how code is loaded. In embedded systems, all code is usually loaded at boot time. In development systems, code is loaded when it is needed, even when the system is running. If testing uncovers bugs, only the buggy code need be replaced.

=== External interfaces ===
- Erlang processes communicate with the outside world using the same message passing mechanism as used between Erlang processes. This mechanism is used for communication with the host operating system and for interaction with programs written in other languages. If required for reasons of efficiency, a special version of this concept allows e.g. C programs to be directly linked into the Erlang runtime system.

=== Fast and Lean ===
- Erlang is fast and lean. A general erlang application has lots of processes. If you are used to OOP you can compare a process with an object. One process per object instance (not class). To make sure the neo could cope with this I watched top while I was busy dialing a phone number on the Aphasia dialer. Each of the twelve buttons are a separate process. Each have its own little animation, and if you look carefully you can see they run in parallell and are acting independent of each other. The top statistics show a really low CPU utilization, I have to dial quite fast to exceed 5% CPU. Next test I made was to measure the time it to takes start these 12 processes and have them display themselves on the screen (aka start the dialer app). It takes approximately 0.5 sec!

== Installation ==


Make sure you have an uboot that is compatible, I used Uboot u-boot-gta01bv4-1.2.0+svnnow-r13_0_2632_0.bin

Install Debian, install script is here http://wiki.openmoko.org/wiki/Debian

Follow the instructions. I had to type in the setenv string and then saveenv.
Reboot to get the new menu_4 title to show up.

=== Install erlang ===

 apt-get install erlang-base


=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]

Download from here [http://projects.openmoko.org/frs/?group_id=59]

In home directory file .profile
<pre>
export DISPLAY=:0
</pre>
Remove "-nolisten tcp" from /etc/X11/xinit/xservrrc

Install xauth package and create .Xauthenticate file
<pre>
debian-gta01:~# apt-get install xauth
debian-gta01:~# xauth
xauth:  creating new authority file /root/.Xauthority
Using authority file /root/.Xauthority
xauth> q
</pre>
When everything is installed you can try this "hello World" code to verify the platform. It will create an empty window.
<pre>
-module(test).
-export([start/0]).
-import(ex11_lib,[eMapWindow/1,xDo/2,xFlush/1,xColor/2,xCreateSimpleWindow/7]).
-include("ex11_lib.hrl").
-define (WT,480).
-define (HT,640).

start() -> spawn(fun win/0).

win() ->
{ok, Display} = ex11_lib:xStart("3.1"),
Win = xCreateSimpleWindow(Display,0,0,?WT,?HT,?XC_arrow,xColor(Display,?blue)),
xDo(Display, eMapWindow(Win)),
xFlush(Display),
loop().

loop() ->
receive
Any -> io:format("Unknown Event~p~n",[Any]), loop()
end.
</pre>
Put this code in a file named test.erl Compile the file with
<pre>
erlc test.erl
</pre>
Run from erlang console.
<pre>
erl
test:start().
</pre>

=== Use mdbus in erlang ===
<pre>
Dbus = open_port({spawn,"mdbus -s"}, [stream, use_stdio, binary]),
loop(Dbus).
</pre>
And get the response
<pre>
loop(Dbus) ->
receive
{Dbus,Msg} -> io:format("Dbus msg:~p~n",[Msg]),loop(Dbus)
end.
</pre>

[[Category:Application Developer]]
