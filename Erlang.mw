== Introduction ==
'''Erlang''' is a programming language which has many features more commonly associated with an operating system than with a programming language: concurrent processes, scheduling, memory management, distribution, networking, etc.

=== Concurrency === 
- Erlang has extremely lightweight processes whose memory requirements can vary dynamically. Processes have no shared memory and communicate by asynchronous message passing. Erlang supports applications with very large numbers of concurrent processes. No requirements for concurrency are placed on the host operating system.

=== Distribution === 
- Erlang is designed to be run in a distributed environment. An Erlang virtual machine is called an Erlang node. A distributed Erlang system is a network of Erlang nodes (typically one per processor). An Erlang node can create parallel processes running on other nodes, which perhaps use other operating systems. Processes residing on different nodes communicate in exactly the same was as processes residing on the same node.

=== Robustness === 
- Erlang has various error detection primitives which can be used to structure fault-tolerant systems. For example, processes can monitor the status and activities of other processes, even if these processes are executing on other nodes. Processes in a distributed system can be configured to fail-over to other nodes in case of failures and automatically migrate back to recovered nodes.

=== Soft real-time === 
- Erlang supports programming "soft" real-time systems, which require response times in the order of milliseconds. Long garbage collection delays in such systems are unacceptable, so Erlang uses incremental garbage collection techniques.

=== Hot code upgrade === 
- Many systems cannot be stopped for software maintenance. Erlang allows program code to be changed in a running system. Old code can be phased out and replaced by new code. During the transition, both old code and new code can coexist. It is thus possible to install bug fixes and upgrades in a running system without disturbing its operation.

=== Incremental code loading === 
- Users can control in detail how code is loaded. In embedded systems, all code is usually loaded at boot time. In development systems, code is loaded when it is needed, even when the system is running. If testing uncovers bugs, only the buggy code need be replaced.

=== External interfaces === 
- Erlang processes communicate with the outside world using the same message passing mechanism as used between Erlang processes. This mechanism is used for communication with the host operating system and for interaction with programs written in other languages. If required for reasons of efficiency, a special version of this concept allows e.g. C programs to be directly linked into the Erlang runtime system.


== Installation ==


Make sure you have an uboot that is compatible, I used Uboot u-boot-gta01bv4-1.2.0+svnnow-r13_0_2632_0.bin

Install Debian, install script is here http://wiki.openmoko.org/wiki/Debian

Follow the instructions. I had to type in the setenv string and then saveenv.
Reboot to get the new menu_4 title to show up.

=== Install erlang ===

 apt-get install erlang-base


=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]

Download from here [http://projects.openmoko.org/frs/?group_id=59]

In home directory file .profile
<pre>
export DISPLAY=:0
</pre>
Remove "-nolisten tcp" from /etc/X11/xinit/xservrrc

Install xauth package and create .Xauthenticate file
<pre>
debian-gta01:~# apt-get install xauth
debian-gta01:~# xauth
xauth:  creating new authority file /root/.Xauthority
Using authority file /root/.Xauthority
xauth> q
</pre>
When everything is installed you can try this "hello World" code to verify the platform. It will create an empty window.
<code>
-module(test).
-export([start/0]).
-import(ex11_lib,[eMapWindow/1,xDo/2,xFlush/1,xColor/2,xCreateSimpleWindow/7,xCreatePixmap/4,ePolyFillRectangle/3,
mkRectangle/4]).
-include("ex11_lib.hrl").
-define (WT,480).
-define (HT,640).

start() -> spawn(fun win/0).

win() ->
Pid = self(),
{ok, Display} = ex11_lib:xStart("3.1"),
Win = xCreateSimpleWindow(Display, 0, 0, ?WT, ?HT, ?XC_arrow, xColor(Display, ?black)),
xDo(Display, eMapWindow(Win)),
xFlush(Display),
loop().

loop() ->
receive
Any -> io:format("Unknown Event~p~n",[Any]), loop()
end.
</code>
Put this code in a file named test.erl Compile the file with
<code>
erlc test.erl
</code>
Run from erlang console.
<code>
erl
test:start().
</code>

=== Install the dbus package ===


Download from here [http://sourceforge.net/projects/dbus-erlang/]

[[Category:Application Developer]]
