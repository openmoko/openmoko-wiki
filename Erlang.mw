{{note |This article is written while I am doing this stuff myself on my Linux Ubunty 8.1 system. If you are on another OS brand or version you will probably have to adjust some parts to make it work. To help understand what commands to type on a terminal on the phone and what to type on a terminal on the host, all phone-terminal text is in green (only on firefox). make sure your *USB_Networking* is set up correctly before you start.}}


== Introduction ==
[http://www.erlang.org Erlang] is a programming language which has many features more commonly associated with an operating system than with a programming language: concurrent processes, scheduling, memory management, distribution, networking, etc.

=== Concurrency ===
- Erlang has extremely lightweight processes whose memory requirements can vary dynamically. Processes have no shared memory and communicate by asynchronous message passing. Erlang supports applications with very large numbers of concurrent processes. No requirements for concurrency are placed on the host operating system.

=== Distribution ===
- Erlang is designed to be run in a distributed environment. An Erlang virtual machine is called an Erlang node. A distributed Erlang system is a network of Erlang nodes (typically one per processor). An Erlang node can create parallel processes running on other nodes, which perhaps use other operating systems. Processes residing on different nodes communicate in exactly the same was as processes residing on the same node.

=== Robustness ===
- Erlang has various error detection primitives which can be used to structure fault-tolerant systems. For example, processes can monitor the status and activities of other processes, even if these processes are executing on other nodes. Processes in a distributed system can be configured to fail-over to other nodes in case of failures and automatically migrate back to recovered nodes.

=== Soft real-time ===
- Erlang supports programming "soft" real-time systems, which require response times in the order of milliseconds. Long garbage collection delays in such systems are unacceptable, so Erlang uses incremental garbage collection techniques.

=== [[Hot code loading]] ===
- Many systems cannot be stopped for software maintenance. Erlang allows program code to be changed in a running system. Old code can be phased out and replaced by new code. During the transition, both old code and new code can coexist. It is thus possible to install bug fixes and upgrades in a running system without disturbing its operation.

=== Incremental code loading ===
- Users can control in detail how code is loaded. In embedded systems, all code is usually loaded at boot time. In development systems, code is loaded when it is needed, even when the system is running. If testing uncovers bugs, only the buggy code need be replaced.

=== External interfaces ===
- Erlang processes communicate with the outside world using the same message passing mechanism as used between Erlang processes. This mechanism is used for communication with the host operating system and for interaction with programs written in other languages. If required for reasons of efficiency, a special version of this concept allows e.g. C programs to be directly linked into the Erlang runtime system.

=== Fast and Lean ===
- Erlang is fast and lean. A general erlang application has lots of processes. If you are used to OOP you can compare a process with an object. One process per object instance. To make sure the neo could cope with this I watched top while I was busy dialing a phone number on the [[Aphasia]] dialer. Each of the twelve buttons are a separate process. Each has its own little animation, and if you look carefully you can see they run in parallell and are acting independent of each other. The top statistics show a really low CPU utilization, I have to dial quite fast to exceed 5% CPU. Next test I made was to measure the time it takes to start these 12 processes and have them display themselves on the screen (aka start the dialer app). It takes approximately 0.5 sec!<br>

[[Image:Dialer.gif]]

== Installation on OpenWRT ==

Follow the guidelines in the [[OpenWRT]] wiki page. Go to "Build Custom Image" and follow the instructions. In "Configure target and packages" scroll down to Languages and select Erlang. In Xorg, select app and mark xauth with a *. 

=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]
Download from http://projects.openmoko.org/frs/?group_id=59 It is sufficient if you take the file at http://projects.openmoko.org/frs/download.php/753/ex11_lib.tgz and unzip it in your source directory.

In file /root/.profile
<font color="green">
<pre>
export DISPLAY=:0
</pre>
</font>

In file /etc/hosts remove . (dot) at the end of line localhost.
<font color="green">
<pre>
127.0.0.1 localhost
</pre>
</font>

In file /root/.erlang
<font color="green">
<pre>
io:format("Running Erlang from root~n").
code:add_patha("/root/trunk").
</pre>
</font>

I keep my erlang source in /root/trunk

Copy Xauthority from host

<pre>
scp .Xauthority phone:/root
</pre>

Add localhost to it with xauth
<font color="green">
<pre>
xauth
add OpenWrt/unix:0 MIT-MAGIC-COOKIE-1  cfcc5ef98f9718f90154f355c0ae9f62
exit
cp .Xauthority /
</pre>
</font>

== Installation on FSO distribution ==

The minimal erlang system is only 4 MB. It fits nicely into whats left in the Freerunner and neo1973 after openmoko-fso-image is installed. 

Download cean_installer.bin from CEAN http://cean.process-one.net/downloads/ At the CEAN Downloads page, select "Installer" and "Production" and "Linux ARMEL" and Download.  Copy the file cean_installer.bin to your neo. To save keystrokes I have added "192.168.0.202 phone" to my /etc/hosts file.

<pre>
scp cean_installer.bin  phone:/home/root
</pre>

Open a terminal window to the phone. Password is blank. Unless you changed it to something you just have to press enter at the prompt.

<pre>
ssh phone
</pre>

Before you can install erlang you have to get a copy of the file libsctp.so.1. I grabbed one from my Debian installation on the cf card at /media/mmcblk0p2/usr/lib/

<font color="green">
<pre>
cp /media/mmcblk0p2/usr/lib/libsctp.so.1 /usr/lib
</pre>
</font>

Or if you get it from your host:
<pre>
scp ./somedir/libsctp.so.1.0.9 phone:/usr/lib/libsctp.so.1
</pre>

Make sure you have "tar" installed on the phone:
<font color="green">
<pre>
opkg update
opkg install tar
</pre>
</font>

Now you are ready to install erlang. On the phone, type
<font color="green">
<pre>
chmod 777 cean_installer.bin
./cean_installer.bin
</pre>
</font>

If all goes well you will see the erlang console prompt

<pre>
Erlang (BEAM) emulator version 5.6.3 [source] [async-threads:0] [kernel-poll:false]

Eshell V5.6.3  (abort with ^G)
1>
</pre>

I use  ^C and then "a" to exit the shell.

=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]
Download from http://projects.openmoko.org/frs/?group_id=59 It is sufficient if you take the file at http://projects.openmoko.org/frs/download.php/753/ex11_lib.tgz and unzip it in your source directory.

In file /home/root/.profile
<font color="green">
<pre>
export DISPLAY=:0
</pre>
</font>

In file /home/root/.erlang
<font color="green">
<pre>
io:format("Running Erlang from root~n").
code:add_patha("/home/root/trunk").
</pre>
</font>

I keep my erlang source in /home/root/trunk

Copy Xauthority from host

<pre>
scp .Xauthority phone:/home/root
</pre>

When everything is installed you can try this "hello World" code to verify the platform. It will create an empty window.
<pre>
-module(test).
-export([start/0]).
-import(ex11_lib,[eMapWindow/1,xDo/2,xFlush/1,xColor/2,xCreateSimpleWindow/7]).
-include("ex11_lib.hrl").
-define (WT,480).
-define (HT,640).

start() -> spawn(fun win/0).

win() ->
{ok, Display} = ex11_lib:xStart("3.1"),
Win = xCreateSimpleWindow(Display,0,0,?WT,?HT,?XC_arrow,xColor(Display,?blue)),
xDo(Display, eMapWindow(Win)),
xFlush(Display),
loop().

loop() ->
receive
Any -> io:format("Unknown Event~p~n",[Any]), loop()
end.
</pre>
Put this code in a file named test.erl Start erlang console

<font color="green">
<pre>
./cean/start.sh
</pre>
</font>

and compile and run the file with
<font color="green">
<pre>
c(test).
test:start().
</pre>
</font>

Note that it is ok to create and compile the file on your host and copy the compiled file "test.beam" to the phone. If you want to compile on the phone you have to install the compiler. Try this in the erlang shell.
<font color="green">
<pre>
cean:install(compiler).
</pre>
</font>

I must admit that for some reason it doesn't work for me. I don't compile on the phone anyway so it's no big deal.

== Installation on SHR-testing distribution ==

Get a version from CEAN, as described above, but get the "Archive", and not the "Installer".  You will need the "libsctp" lib, too, but it's not in SHR anywhere.  You can get a compatible .so out of the .deb package from this link [http://packages.debian.org/lenny/armel/libsctp1/download].  Find the file libsctp.so.1.0.9, and save it to /usr/lib/ on your SHR freerunner.  You should now be able to start the erlang shell.

== Installation on Debian distribution ==

Make sure you have an uboot that is [http://wiki.openmoko.org/wiki/Flashing_the_Neo_FreeRunner#Flashing_the_boot_loader_to_the_NAND compatible], I used Uboot u-boot-gta01bv4-1.2.0+svnnow-r13_0_2632_0.bin

Install Debian, install script is here http://wiki.openmoko.org/wiki/Debian

Follow the instructions. I had to type in the setenv string and then saveenv.
Reboot to get the new menu_4 title to show up.

<font color="green">
<pre>
apt-get install erlang-base
</pre>
</font>

=== Install the GUI package ex11 ===
Take a look at this example of what you can do with ex11 [http://projects.openmoko.org/docman/view.php/59/22/MAQ01113.MP4]

Download from http://projects.openmoko.org/frs/?group_id=59 It is sufficient if you take the file at http://projects.openmoko.org/frs/download.php/437/ex11lib.zip and unzip it in your source directory.

In home directory file .profile
<font color="green">
<pre>
export DISPLAY=:0
</pre>
</font>
Remove "-nolisten tcp" from /etc/X11/xinit/xservrrc

Install xauth package and create .Xauthority file
<font color="green">
<pre>
debian-gta01:~# apt-get install xauth
debian-gta01:~# xauth
xauth:  creating new authority file /root/.Xauthority
Using authority file /root/.Xauthority
xauth> q
</pre>
</font>
Copy .Xauthority to /


When everything is installed you can try this "hello World" code to verify the platform. It will create an empty window.
<pre>
-module(test).
-export([start/0]).
-import(ex11_lib,[eMapWindow/1,xDo/2,xFlush/1,xColor/2,xCreateSimpleWindow/7]).
-include("ex11_lib.hrl").
-define (WT,480).
-define (HT,640).

start() -> spawn(fun win/0).

win() ->
{ok, Display} = ex11_lib:xStart("3.1"),
Win = xCreateSimpleWindow(Display,0,0,?WT,?HT,?XC_arrow,xColor(Display,?blue)),
xDo(Display, eMapWindow(Win)),
xFlush(Display),
loop().

loop() ->
receive
Any -> io:format("Unknown Event~p~n",[Any]), loop()
end.
</pre>
Put this code in a file named test.erl Compile the file with
<font color="green">
<pre>
erlc test.erl
</pre>
</font>
Run from erlang console.
<font color="green">
<pre>
erl
test:start().
</pre>
</font>

== Erlang development environment ==
You can in fact choose any text editor, and use a terminal window to compile and copy compiled erlang beam-files to the phone. However, I have found SciTE to be a nice choice. It has erlang colour coding, bracket matching, code completion and lots of more stuff you are accustomed to find in a programmers editor. And it's easily configurable to handle compilation and error tracking, click on an error message to go to the line where the error is located.

In addition to all this you can set it up to let you run your erlang app on the host, and to copy the compiled app to the phone and run it there. All from within SciTE. This gives a very fast turnaround time, I can compile my app - run on host - copy to neo - run on neo in less than a minute. Part of this fast development cycle is of course due to the fact that erlang is platform agnostic - the same compiled code runs on Arm and Intel Linux and Windows.

{{note |Other options for erlang developers are Eclipse and NetBeans. Add [http://erlide.sourceforge.net/ erlIDE] to Eclipse or use [http://sourceforge.net/projects/erlybird ErlyBird] }}


=== You don't need an emulator ===
All you need to run a phone application on your host is erlang and an X-server. Are you running linux it's just to install erlang and you are done. On a Mac you also have to install the Apple X-server app. It works right out of the box, and is a free download from www.apple.com. Textmate is the recommended erlang ide for mac-users. Windows users have to take another path. You develop and compile erlang source on your windows box, and use erlang's built in [[hot code loading]] to run your code right on the phone without any restart or reboot.

=== Install SciTE ===
Download from here http://www.scintilla.org/SciTE.html and install. If you have apt-get it can be as easy as
<pre>
sudo apt-get install scite
</pre>

=== Seting up SciTE for openmoko development ===
Before you start configuring SciTE, make sure ssh, scp and rsh works from a terminal window.
I have to run this script whenever I connect the neo to the host
<pre>
#!/bin/bash
ifconfig usb0 192.168.0.200 netmask 255.255.255.0
/sbin/route add -host 192.168.0.202/32 dev usb0
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
iptables -P FORWARD ACCEPT
</pre>

Start SciTE and select menu Options|Open Global Options and uncomment
<pre>
#Erlang|erl||\
</pre>
and at other lines where erlang is a comment. You may have to start SciTE as root to do this. (To uncomment you just delete the hash at the beginning of the line).

Create a file named SciTE.properties in your erlang source directory.
<pre>
# SciTE.properties is the per directory local options file and can be used to
# override settings made in SciTEGlobal.properties, SciTEUser.properties and
# SciTEDirectory.properties.
command.compile.*.erl=erlc $(FileName).erl
command.go.subsystem.*.erl=0
command.go.*.erl=erl -noshell -s $(FileName) start 
command.subsystem.1.*.erl=0
command.name.1.*.erl=svn update
command.1.*.erl= svn update $(FileNameExt)
command.name.2.*.erl= svn ci
command.2.*.erl= svn ci -m '$(4)' $(FileNameExt)
command.name.3.*.erl=svn co
command.3.*.erl=*svn co $(1)
command.name.4.*.erl=svn status
command.4.*.erl= svn status
command.name.5.*.erl=hot code loading
command.5.*.erl=erl -noshell -setcookie SFEWRG34AFDSGAFG35235 -name moko2@192.168.0.200 -eval "net_adm:ping('neo@192.168.0.202'), c:nl($(FileName))." -s init stop
command.subsystem.6.*.erl=0
command.name.6.*.erl=copy to neo1973
#command.6.*.erl= scp $(FileName).beam   phone:/root/erlang/trunk/ #Debian
command.6.*.erl= scp $(FileName).beam   phone:/home/root/trunk/
command.subsystem.7.*.erl=0
command.name.7.*.erl=add to subversion
command.7.*.erl= svn add $(FileNameExt)
command.subsystem.8.*.erl=0
command.name.8.*.erl=stop X
command.8.*.erl= rsh root@192.168.0.202 /etc/init.d/xserver-nodm stop
#command.8.*.erl= rsh root@192.168.0.202 /etc/init.d/zhone-session stop #Debian
command.subsystem.9.*.erl=0
command.name.9.*.erl=start
command.9.*.erl= rsh root@192.168.0.202 /etc/init.d/xserver-nodm start
#command.9.*.erl= rsh root@192.168.0.202 /etc/init.d/zhone-session start #Debian
abbreviations.*.erl=$(SciteUserHome)/erl_abbrev.properties
line.margin.visible=1
line.margin.width=2+
style.*.33
</pre>

==Runtime Environment==
I am developing a vertical market product based on Openmoko, so I want my erlang platform alone to run (no window manager nor Zhone) when the phone is switched on.

===Quick and dirty===
Remove packages Enlightenment and Illume.
<font color="green">
<pre>
opkg -recursive remove e-wm
</pre>
</font>

This is my  /etc/X11/Xsession.d/90xXWindowManager. I keep my erlang beam files at /home/root/trunk.
<font color="green">
<pre>
#!/bin/sh -e
/home/root/cean/start.sh -setcookie SFEWRG34AFDSGAFG35235 -name neo@192.168.0.202 -noshell -pa /home/root/trunk -s main start > debug.txt
</pre>
</font>


For Debian users it's /usr/bin/zhone-session. I keep my erlang beam files at /root/erlang/trunk
<font color="green">
<pre>
#zhone &
#matchbox-keyboard-toggle &
erl -setcookie SFEWRG34AFDSGAFG35235 -name neo@192.168.0.202 -noshell -pa /root/erlang/trunk -s main start > debug.txt
#exec matchbox-window-manager -use_titlebar no
</pre>
</font>

Replace "-s main start" with "-s your_module_name your_function_name"


All I have to do now is to re-start X whenever I want to run an uploaded app. This is what the last two menu buttons do in SciTe - stop X on the phone, and start X on the phone. As an alternative for stopping and starting X you can use Erlang's built-in [[hot code loading]]. 


[[Image:Scite.jpg]]


The svn xxx menu items is for version control if you are [[Using Subversion]].

Type
<pre>
ssh phone
</pre>
to get a terminal window and type
<font color="green">
<pre>
tail -f /debug.txt
</pre>
</font>
to read shell printout from the erlang process.

===The right way===
The better installation would be to install a minimal system and then add Erlang.

This is my runtime environment file system when erlang is installed "Quick-and-dirty" in FSO:
<font color="green">
<pre>
root@om-gta02:~# df -h
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/root               252544     93980    158564  37% /
/dev/root               252544     93980    158564  37% /dev/.static/dev
udev                      2048        44      2004   2% /dev
/dev/mmcblk0p1          497920         0    497920   0% /media/card
tmpfs                    60400        52     60348   0% /var/volatile
tmpfs                    60400         0     60400   0% /dev/shm
</pre>
</font>

Compare to this filesystem on OpenWRT minimal with Erlang installed:
<font color="green">
<pre>
root@OpenWrt:/# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root               246.6M     39.6M    207.0M  16% /
tmpfs                    61.8M     44.0K     61.7M   0% /tmp
tmpfs                   512.0K         0    512.0K   0% /dev
</pre>
</font>

== Example Code ==
=== Use [[D-Bus]] in erlang ===
<pre>
Dbus = open_port({spawn,"mdbus -s"}, [stream, use_stdio, binary]),
loop(Dbus).
</pre>
And get the response
<pre>
loop(Dbus) ->
receive
{Dbus,Msg} -> io:format("Dbus msg:~p~n",[Msg]),loop(Dbus)
end.
</pre>

== Graphics ==
I'm using vector graphics to produce new widgets. Vector graphics is lightweight and programmable, easy to scale and rotate, and the Byte-Size is small. Use any vector-capable drawing application. I happen to use AutoCAD LT on Wine, but please suggest an open source alternative and I will be happy to create another small conversion program to translate the new drawing file to erlang source. If you have access to AutoCAD, take dxf2erl.erl from [http://projects.openmoko.org/frs/?group_id=59 here]
 
=== Drawing a widget in AutoCAD LT ===

Screencast [http://www.kvamme.se/Aphasia/Erlang_files/mokobattery.mov here]

=== Convert drawing to erlang source ===

Screencast [http://www.kvamme.se/Aphasia/Erlang_files/battery.mov here]


[[Category:Application Developer]]
