[[Category:USB]]
[[Category:Implemented]]
[[Category:Networking]]

{{Languages|USB_Networking}}

{|align=left
|__TOC__
|}

= Openmoko Networking Setup =

In order to communicate via TCP/IP to your FreeRunner, a basic understanding of the networking expectations is required.  Each end of the USB connection forms a LAN (local area network) segment, with the FreeRunner's USB networking device at one end (default 192.168.0.202) and your laptop or desktop at the other end (192.168.0.200 in this guide).

Normally, your desktop machine will know how to reach the Internet, having had its gateway (the IP address of the machine or device which knows how to send packets to machines beyond your subnet) configured via DHCP or statically (probably via a router).  For the FreeRunner to reach the Internet, your desktop will have to be configured to route and masquerade (NAT) packets from it.

Normally, none of this is an issue, but problems can arise when the subnet between the FreeRunner and your desktop overlap with the desktop to the router (which forms a second LAN), since your desktop might not know how to route traffic properly.

In other words: if your existing router and desktop have addresses 192.168.0.(something) changing them to e.g. 192.168.1.(something) might save you a lot of troubleshooting later. A discussion of this is [http://lists.openmoko.org/pipermail/support/2008-August/thread.html#1277 here].

== Things to keep in mind ==

* When the FreeRunner suspends it disables its USB networking interface. Therefore it is a good idea to turn off the FreeRunners suspend function when using USB networking. You can do this manually or automatically. [https://wiki.muc.ccc.de/openmoko This] site has two scripts ([https://wiki.muc.ccc.de/openmoko#disable_suspend_if_on_external_power one for Om 2007] and [https://wiki.muc.ccc.de/openmoko#disable_suspend_if_on_external_power1 one for Om 2008]) which disable suspend if the FreeRunner is on external power.

Some scripts do a tail-grep on certain log file. If you have disabled syslog and/or klog, this might be a problem for detecting when the device is connected to your machine via USB. When logging is disabled, it can be enabled on Ubuntu be /etc/init.d/klogd restart; /etc/init.d/sysklog restart

== So is it "usb0" or is it "eth1"? ==

* The documentation below refers to the network interface name on the host side as "usb0".  However, the actual name is determined by your host system, and many host systems will rename the interface based on the mac (or hardware) address presented by the Neo or Freerunner.  Use the "ifconfig -a" command, or use "dmesg" to examine the output from your host's kernel, to find which interface name was actually assigned to your device.  If it wasn't "usb0", it will almost always be the next available "eth''n''" name.

In all the steps below where you see the interface referred to as "usb0", you may need to substitute the interface name that your host assigned.

For those interested in the technical details, the "usb0" interface name is used on the host system when the mac (hardware) address presented by the Freerunner or Neo is a locally-generated (random) address.  Because the address is random, the ability to easily manage the interface with network managment tools is somewhat compromised. In fact, the Freerunner has been assigned official mac addresses, including addresses for the USB network interface.  When these addresses are correctly used on the Freerunner (which is the case with the Qi bootloader, and with certain of the distros for the Freerunner), then the host system sees official mac addresses, and responds by configuring a permanent network interface for that device.  By convention, this permanent interface is one of the "eth" interfaces.  The specific interface name chosen will be remembered, and will be used each time that specific Freerunner is connected, and used only for that Freerunner.  This is a particularly useful feature for users who have multiple USB-networked devices.

As of the time of this writing, the Android and SHR distros will correctly pass the official mac address to the host, and will appear as "eth''n''" interfaces on the host.

= Simple Manual Linux Configuration =
Try this first (as root on your desktop, with FreeRunner attached via USB cable and booted properly, not at the Boot Menu).  If it works, then you can add permanent configuration or use more sophisticated setups below.
=== The shortest way ===
This simple way has been tested with many Linux distributions (Fedora, SuSE, Red Hat, Debian and others) and network configurations. It was even successfully applied to connect another Linux based handhelds like TDS Nomad and surely can be recommended as the first attempt. The way assumes that you have the recent Linux distribution with USB networking enabled and also rather typical network setup. 

With the device connected configure usb0 interface (as root):
<pre>
sudo ip address add 192.168.0.200/24 dev usb0
</pre>
or (deprecated)
<pre>
sudo ifconfig usb0 192.168.0.200 netmask 255.255.255.0
</pre>
If your eth0 interface is also in the same 'range' (e.g. 192.168.0.105) then you can do the following:

1. ping the Neo with
 # ping -I usb0 192.168.0.202
2. log in to the Neo (you do not need to be a root on the desktop host just to log in).
 # ssh root@192.168.0.202
The default password is blank.

Do not forget to allow ssh (open the port 22) on your firewall so that you can connect to the device. If you suspect any firewall issues, the simplest way is to unplug the main Internet cable leaving only Neo connected and then temporary turn the firewall off.

Also, some old or narrowly configured Linux distributions may not have USB networking support. For such cases the simple way might be just to upgrade.

=== The more advanced way ===
If the previously described simple approach does not work, you may try the more complex one.

<pre>iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
sysctl -w net.ipv4.ip_forward=1
ip addr add 192.168.0.200/24 dev usb0</pre>

If your Internet connection is also in the range 192.168.0.x then instead you might want to use only:

<pre>ip addr add 192.168.0.200/28 dev usb0</pre>

(This will just map the net from 192.168.0.192 to 192.168.0.207 onto usb0. If you get the error 'Cannot find device "usb0"', double-check that your FreeRunner is turned on and connected by USB. If that doesn't work, try unplugging and replugging the USB cable.)

And in this case you should enable ARP proxy on internet facing interface INSTEAD of using iptables:

<pre>sysctl net.ipv4.conf.eth2.proxy_arp=1</pre>

This assuming that eth2 is connected to ISP.

Then
<pre>ip link set usb0 up</pre>
or (deprecated)
<pre>ifconfig usb0 up</pre>

Then (ideally, not as root):

<pre>ssh root@192.168.0.202</pre>

The default password is blank.

Due to the fact that in most cases your Neo will use the same dns servers as your computer uses, you can automate the process of writing dns servers to your phone:

<pre>#!/bin/sh
/sbin/route add -host 192.168.0.202/32 dev usb0
iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
iptables -P FORWARD ACCEPT
sysctl -w net.ipv4.ip_forward=1
scp /etc/resolv.conf root@192.168.0.202:/etc/resolv.conf</pre>

Again if your net already is 192.168.0.0, replace the POSTROUTING statement with
<pre>iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/28</pre>

This simple script will set up routing for your Freerunner and than copy resolv.conf with dns addresses straight to the phone.
All you have to do is connect phone to the computer, run the script and enjoy internet connection from your phone.

=== Changing the Neo IP address ===

Like mentioned above, if the default Neo subnet 192.168.0.X is already used, it might be necessary to change the
Neo [http://en.wikipedia.org/wiki/IP_address IP adress] and subnet.
To achieve this, edit /etc/network/interfaces on the Neo (and reboot it).
In the following example the Neo will use the IP address 192.168.100.1 (instead of the default 192.168.0.202)
within the network 192.168.100.X (instead of 192.168.0.X),
another [http://en.wikipedia.org/wiki/Private_network private] class C network.
(The [http://en.wikipedia.org/wiki/Subnetwork#Binary_subnet_masks netmask] indicates that the first 3 bytes (all bits set) are used to determine the subnet
and the last byte (no bits set) to determine the machine.)
The gateway (the computer, the Neo is attached to) also has to be part of the subnet and is expected to be 192.168.100.254 (instead of 192.168.0.200) here.

Modifications for /etc/network/interfaces:

<pre>
auto usb0
iface usb0 inet static
        address 192.168.100.1
        netmask 255.255.255.0
        network 192.168.100.0
        gateway 192.168.100.254
</pre>

(The network entry seems to be redundant information, since it can be derived from address and netmask?)
Note that wiki articles usually expect default settings and you have to adjust the IP adress, gateway, etc entries according to your changes.

= Linux Kernel Support =

Your Linux desktop/laptop needs to have suitable support. In particular you will need to have enabled USB networking and masquerading support in the kernel. For default kernels in many Linux distributions this will already be the case.

== USB Networking support ==

The following options need to be enabled:

* CONFIG_USB_USBNET (''Multi-purpose USB Networking Framework''. Module will be called <tt>usbnet</tt>)
* CONFIG_USB_NET_CDCETHER (''CDC Ethernet support''. Module will be called <tt>cdc_ether</tt>)

These options are available in ''Device Drivers -> USB support -> USB Network Adapters'' or ''Device Drivers -> Network Device Support -> USB Network Adapters.

In order for USB networking to work you need to load the <tt>cdc_ether</tt> module (when loading <tt>cdc_ether</tt> the module <tt>usbnet</tt> will be loaded automatically). For more info see the [http://www.linux-usb.org/usbnet/ usbnet driver homepage].

Olamba

== Masquerading support ==

Masquerading options are found in ''Networking ---> Networking options --->'' (tested on Linux 2.6.26.3).

To enable the needed options you first have to enable:

* CONFIG_NETFILTER (''Network packet filtering framework (Netfilter)'')

Then, from

''Networking --->
Networking options --->
[*] Network packet filtering framework (Netfilter) --->
Core Netfilter Configuration --->''

You need at least following options enabled as modules:

* CONFIG_NF_CONNTRACK (''Netfilter connection tracking support'')
* CONFIG_NF_CONNTRACK_FTP (''FTP protocol support'')
* CONFIG_NETFILTER_XTABLES (''Netfilter Xtables support'')

Rest of the needed options are found from

''Networking --->
Networking options --->
[*] Network packet filtering framework (Netfilter) --->
IP: Netfilter Configuration --->''

You need to enable (again, as modules is fine):

* CONFIG_NF_CONNTRACK_IPV4 (''IPv4 connection tracking support (required for NAT)'')
* CONFIG_IP_NF_IPTABLES (''IP tables support (required for filtering/masq/NAT)'')
* CONFIG_NF_NAT (''Full NAT'')
* CONFIG_IP_NF_TARGET_MASQUERADE (''MASQUERADE target support'')

= Firewall Issues =

On some systems, you may have firewall rules which prevent this working - such as added by the iptables service on Fedora.  You may care to stop these, and/or review any rules or policies you think might cause issues.

The most relevant table is the nat table, which controls translation of addresses:

iptables -L -t nat -v -n

Unless you have a special setup, you'll want to see only the MASQUERADE rule that you apply below, and ACCEPT as the default policy.  Also look at the filter table:

iptables -L -t filter -v -n

If this contains anything in the FORWARD chain, then this may prevent passing packets.  It can be flushed with:

iptables -t filter -F FORWARD

= DNS =

In addition to routing issues, to be practical, DNS will need to work.  In some cases, you might already be running a DNS server on your desktop such as dnsmasq or bind9, which is the default assumption the FreeRunner makes.  In other cases, you'll need to configure DNS to that of your router, or a DNS server further out on the internet such as that provided by your ISP.

== Configure Default Neo DNS ==

DNS is configured in /etc/resolv.conf on your FreeRunner.

You should add the IP address of the DNS servers as provided by your ISP. Check your router's or PC's network status for the nameserver IP addresses.

<pre>echo nameserver xxx.xxx.xxx.xxx > /etc/resolv.conf</pre>

You can also add the public DNS server called openDNS:
<pre>echo nameserver 208.67.222.222 > /etc/resolv.conf
echo nameserver 208.67.220.220 >> /etc/resolv.conf</pre>

These settings will be lost on reboot. You can set the DNS for the next connect, by adding the following to the end of the usb0 setting in /etc/network/interfaces, right above the bluetooth networking section:
<pre>up echo nameserver 208.67.222.222 > /etc/resolv.conf
up echo nameserver 208.67.220.220 >> /etc/resolv.conf</pre>

== Proxying DNS from Desktop/Laptop ==

If you move about, making assumptions about the network may not be convenient, and it is possible to proxy DNS requests via your host laptop (which you are also taking with you), without running or installing a DNS server.  There are a number of ways to do this:

=== Proxying with dnrd ===

The script is designed to use [http://dnrd.sourceforge.net/ dnrd] as the DNS proxy. The [http://buildhost.automated.it/gta01 script] and a copy of [http://buildhost.automated.it/dnrd-2.20.3.tar.gz dnrd] are available. The script also performs the initial setup of the connection as per the [[USB_Networking#Manual_method]] above.

=== Proxying with a UDP forwarder ===

Another easy setup is using a UDP forwarder like the one from http://www.tapor.com/udpf/ - use it with the command"

<pre>udpf-elf -p=53-f=`awk '$1 == "nameserver"{print $2; exit(0);}' /etc/resolv.conf`:53</pre>

=== Proxying with iptables ===

It is possible to forward DNS requests with iptables using the DNAT target:

<pre>iptables -t nat -A PREROUTING -p tcp -s 192.168.0.202 -d 192.168.0.200 --dport domain -j DNAT --to-destination 192.168.0.1
iptables -t nat -A PREROUTING -p udp -s 192.168.0.202 -d 192.168.0.200 --dport domain -j DNAT --to-destination 192.168.0.1</pre>

Where <tt>192.168.0.1</tt> is the IP of your router.

Test if it works:
<pre>ping www.google.com</pre>

If so, then this is sufficient for most internet access. But manual changes to resolv.conf are usually lost later if for example one uses DHCP, especially for WiFi, and so may not be convenient to configure manually.

= Testing Your Connection =
You should be able to connect to your Neo! Make sure you can ping your Neo to be sure.
ping 192.168.0.202

Then log into your Neo using ssh:
ssh root@192.168.0.202
The default password is blank (press enter).

You can also [[scp]] files back and forth. You can telnet, SSH, SMB or do whatever you want if you install software that enables you to set up TCP/IP network over your USB connection.

Now, make sure you can ping back to your desktop
ping 192.168.0.200
(Note that some systems like Vista, don't respond to ICMP ping by default)

Try pinging the outside world (a Google IP address)
ping 74.125.19.147
This demonstrates that masquerading is working - your desktop is sending/receiving packets to the wider internet.

Lastly, verify that DNS is correctly configured between the Neo & Network:
ping www.google.com

= OS or Distro Specific & Automatic Configuration =

Based on [http://blog.haerwu.biz/2007/03/22/hotpluging-usbnet/ Hotplugging usbnet] by Marcin 'Hrw' Juszkiewicz.
These instructions should keep you from having to run the Simple Manual Linux Configuration every time you plug in and want to connect to an Openmoko device.  One run and then you're done!

If the Simple Manual Linux Configuration does not work for your OS or Distro (MacOS X, MS Windows, etc) there may be instructions here that work for you.

== MacOS X ==
See [[MacOS_X#USB_Networking|MacOS X USB Networking]].

== Windows ==
See [[Neo1973_and_Windows#USB_Ethernet_emulation|Windows USB Ethernet emulation for Neo1973]].

There is also a very helpful tutorial for connecting with Vista at [http://sam.curren.ws/index.cfm/2008/7/14/Using-the-Neo-FreeRunner-with-Windows-XPVista].

== FreeBSD ==
You need to load the cdce kernel module (if it is not already linked into your kernel). As root do:

 # kldload cdce

The Neo should then show up as cdce0 interface and you can handle the cdce0 interface just like the usb0 device under Linux. For more information see the cdce manpage. An easy way to assign the IP address to the cdce0 interface is using the devd(8) daemon. Create the following two files,

<tt>/usr/local/etc/devd/cdce.conf</tt> as:

<pre>
notify 1 {
match "system"          "IFNET";
match "subsystem"       "cdce0";
match "type"            "ATTACH";
action "/usr/local/etc/devd/cdce.sh $subsystem $type";
};
</pre>

and <tt>/usr/local/etc/devd/cdce.sh</tt> as:

<pre>
#!/bin/sh
case $2 in
'ATTACH')
ifconfig cdce0 192.168.0.200 netmask 255.255.255.0
exit 0 ;
;;
esac
exit 0
</pre>

Then restart the devd(8) daemon with:

 # /etc/rc.d/devd restart

If you now plugin the FreeRunner into the USB port the cdce0 interface gets created and the IP addr will be assigned.

== Debian, Ubuntu and others ==

There are two systems which deal with hotplugginng devices, which is what you do when you plug in Freerunner in an <usb port. '''Hotplug''', and more recent system '''udev'''.
 
===Using the interfaces file- works on systems using''' hotplug''' ===
Edit /etc/network/interfaces and add:

<pre>
# freerunner
allow-hotplug usb0
iface usb0 inet static
        address 192.168.0.200
        netmask 255.255.255.0
        up iptables -A POSTROUTING -t nat -s 192.168.0.0/24 -j MASQUERADE
        up echo 1 > /proc/sys/net/ipv4/ip_forward
        down iptables -D POSTROUTING -t nat -s 192.168.0.0/24 -j MASQUERADE
</pre>

This is more sophisticated than the manual setup.  The 'auto usb' stanza ties into the Linux hotplug system so that when the device appears and vanishes, as happens when the FreeRunner is connected via USB, this is run.

In addition, the desktop-side netmask is limited to a much smaller range, so that overlapping subnets are less of a problem - Linux will use more specific routes first when deciding where to send packets.

Another possible configuration that adds DNS forward and removes
the iptables changes after unplugging:

in /etc/network/interfaces add
<pre>
# freerunner
allow-hotplug usb0
iface usb0 inet static
        address 192.168.0.200
        netmask 255.255.255.192
        post-up /etc/network/freerunner start
        pre-down /etc/network/freerunner stop
</pre>

create file /etc/network/freerunner
<pre>
#!/bin/sh
#
# configures the freerunner for internet
#
#

DEVICE=usb0
IPADDR=192.168.0.200
REMOTE_IPADDR=192.168.0.202
NETMASK=255.255.255.0

# get first ip for dns
DNSIP=$(awk '$1 == "nameserver"{print $2; exit(0);}' /etc/resolv.conf)

case "$1" in
start)
iptables -A POSTROUTING -t nat -j MASQUERADE -s $REMOTE_IPADDR
iptables -A PREROUTING -t nat -p tcp -s $REMOTE_IPADDR -d $IPADDR --dport domain -j DNAT --to-destination $DNSIP
iptables -A PREROUTING -t nat -p udp -s $REMOTE_IPADDR -d $IPADDR --dport domain -j DNAT --to-destination $DNSIP

if [ "$(cat /proc/sys/net/ipv4/ip_forward)" = "0" ]; then
echo "temoprarely allow ip_forward for openmoko" > /var/run/openmoko.ip_forward
echo 1 > /proc/sys/net/ipv4/ip_forward
fi
;;
stop)
iptables -D POSTROUTING -t nat -j MASQUERADE -s $REMOTE_IPADDR
iptables -D PREROUTING -t nat -p tcp -s $REMOTE_IPADDR -d $IPADDR --dport domain -j DNAT --to-destination $DNSIP
iptables -D PREROUTING -t nat -p udp -s $REMOTE_IPADDR -d  $IPADDR --dport domain -j DNAT --to-destination $DNSIP

if [ -f /var/run/openmoko.ip_forward ]; then
rm /var/run/openmoko.ip_forward
echo 0 > /proc/sys/net/ipv4/ip_forward
fi
;;
esac
</pre>

Make /etc/network/freerunner executable with
 chmod +x /etc/network/freerunner

=== Using network-manager on systems using '''udev''' ===
It is possible to use network-manager to automatically connect to the Freerunner using udev. The process uses udev to run a script when the Freerunner is plugged in.  The script uses the ip command to set the mac address of the usb network interface. To begin, create /etc/udev/rules.d/80-freerunner.rules :

<pre>
# This file causes programs to be run on device insertion.
# See udev(7) for syntax.
# rule to assign a fixed mac address specified in /
KERNEL=="usb[0-9]*", DRIVERS=="cdc_ether", ACTION=="add", RUN+="/usr/local/sbin/freerunner-usb-add.sh %k"
</pre>

Next, create the /usr/local/sbin/freerunner-usb-add.sh :

<pre>
#!/bin/sh
(
busNum=$( printf %.2d $( expr match "$1" "usb\([0-9]*\)") )
ip link set "$1" address 00:00:22:55:bb:$busNum &> /dev/null
) &
exit 0
</pre>

Finally run "chmod +x /usr/local/sbin/freerunner-usb-add.sh" to make it executable. Now you can use network-manager with '''mac-address specific settings''' and get it to automatically connect.

* Plug your phone into your computer's usb port.
* Note the mac address from "ifconfig usb0"
* Right-click the network manager icon in the panel.
* Click "Edit Connections..."
* Delete the "Auto usb0" entry.
* Add a new connection named 'usb0'
* Tick "System setting"
* Enter the mac address from above.
* Click the "IPv4 Settings" tab.
* Change "Method" to "Manual"
* Add an address of 192.168.0.200, 255.255.255.0 (address and netmask respectively).
* Click "Ok"
* Enter your system password (if prompted) to allow changing of this system setting.

(watch out for this bug: https://bugs.launchpad.net/ubuntu/+source/network-manager/+bug/284298 )

You should now be able to ping/ssh your phone. 

=== Ubuntu 9.04 - the Jaunty Jackalope -- udev=== 

One can see /etc/udev/rules.d that a device plugged in on USB will be called '''eth1'''. Go to system->Administration->Network and add the parameters for eth1 < static ip, address 192.168.0.200 mask 255.255.255.192 add your default gateway>. Thats is all.
--[[User:Frank|frank]] 14:11, 17 June 2009 (UTC)

=== Ubuntu 8.10 - Easy Way === 

:1. Connect Neo to PC and wait about a minute when NetworkManager stops scanning usb for dhcp (wait when icon in the tray switches to normal).

:2. Open "nm-connection-editor", select "Auto usb0", click "Edit", then "IPv4 Settings". Set "Method" - "Manual", click "Add". In the "Address" field write "192.168.0.200", "Netmask" - "255.255.255.0", leave "Gateway" field empty (or 0.0.0.0). Change the "Connection name" and click "Apply", then "Close".

:3. Now you can connect via ssh to 192.168.0.202

Note: After reflashing the Neo you have to copy the "MAC Address" from "Auto usb0" into your new connection.

Then, based on [http://sebastian-bergmann.de/index.php?url=archives/801-OpenMoko-Freerunner-and-Ubuntu.html#feedback these instructions], you should be able to setup masquerading by running the following commands on your Ubuntu PC: 

<pre>sudo iptables -I INPUT 1 -s 192.168.0.202 -j ACCEPT
sudo iptables -I OUTPUT 1 -s 192.168.0.200 -j ACCEPT
sudo iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
sudo bash -c 'echo 1 > /proc/sys/net/ipv4/ip_forward'</pre>

=== Ubuntu Issues ===

Ubuntu 8.10 doesn't work as expected if you used /etc/network/interfaces to automate the connection.<br>
Network manager likes to latch onto the network device and add a default route through 192.168.0.202, breaking your network connection.
Network manager also says you can't edit or remove this connection from its list. I'm going back to making the connection manually.<br>
Using the /usr/local/sbin/freerunner-usb-add.sh script for some automatism can be a workaround:
<pre>
#!/bin/sh
(
ip address add 192.168.0.200/26 netmask dev usb0 > /dev/null
ip link set usb0 up > /dev/null
/etc/network/freerunner start
) &
exit 0
</pre>

Ubuntu Feisty, Gutsy and Hardy reportedly have a bug where ifdown is not run when the interface is unplugged, meaning this only works once after the system is booted.  This is mentioned at https://bugs.launchpad.net/ubuntu/+source/ifupdown/+bug/130437

One can patch /etc/udev/rules.d/85-ifupdown.rules. Moving the DRIVERS=="*?" out of the top GOTO, to ACTION=="add" line fixes the problem.

<pre>
SUBSYSTEM=="net", GOTO="net_start"
GOTO="net_end"

LABEL="net_start"

# Bring devices up and down only if they're marked auto.
# Use start-stop-daemon so we don't wait on dhcp
ACTION=="add", DRIVERS=="?*",       RUN+="/sbin/start-stop-daemon --start --background --pidfile /var/run/network/bogus --startas /sbin/ifup -- --allow auto $env{INTERFACE}"
ck
ACTION=="remove",       RUN+="/sbin/start-stop-daemon --start --background --pidfile /var/run/network/bogus --startas /sbin/ifdown -- --allow auto $env{INTERFACE}"

LABEL="net_end"
</pre>

The bug is that the DRIVERS variable isn't set at all when the device is unplugged.

This appears to be fixed in Ubuntu 8.04 [[User:Mattt|Mattt]] 11:38, 30 July 2008 (UTC)
:Actually it appears that it's not fixed, but patching that file and disconnecting and reconnecting the phone works perfectly. --[[User:Johndoesacc|Johndoesacc]] 18:37, 20 August 2008 (UTC)
:Well, yes, it must be fixed because it worked for me out-of-the-box without tweaking the udev rule on 8.04 --[[User:EtienneG|EtienneG]] November 26th, 2008
:It wasn't solved in my case, as of 3. February 2009 in 8.04 (AMD64), the patch above solved my problem thou. --[[User:VilleWitt|VilleWitt]] February 3td, 2009.

====Iptables Configuration with GUI====

Firestarter can be used to allow the freerunner to connect to the internet without manually running iptables commands. Firestarter is in the ubuntu repositories and can be installed with a 
<pre>sudo aptitude install firestarter</pre>
Once installed, the firestarter preferences dialog has a network section, under which a drop-down box appeasr which is labeled  "Local network connected device." Select the freerunner, generally "Unknown device(usb0)" and check the "Enable internet connection sharing" box. Uncheck local network DHCP and the freerunner should be able to access the internet.
-Tested in ubuntu 8.10--[[User:makito|Makito]] February 26, 2009

Note: Firestarter needs to run as root.

=== Ubuntu Workaround ===
Use [http://wicd.sourceforge.net/ wicd] instead of networkmanager:
It is much further in development than networkmanager yet and doesn't make any problems with USB networking. You can use the "normal" settings in /network/interfaces.
;Note: Because of it's dependencies it deinstalls networkmanager.

=== Ubuntu and QI ===
If you have trouble connecting to the freerunner after installing qi, check to see if the address has changed to eth<n>. Many host systems will assign eth<n> addresses when they detect an official (non-locally-generated) mac address on the usb network connection.  Qi passes in the official Openmoko USB mac address; u-boot does not.

== Mandriva ==

This first file configures the network system for the usb0 interface. Any time you plug in the FreeRunner the interface will be configured.

<tt>/etc/sysconfig/network-scripts/ifcfg-usb0</tt>:

<pre>
DEVICE=usb0
BOOTPROTO=static
IPADDR=192.168.0.200
NETMASK=255.255.255.0
NETWORK=192.168.0.0
BROADCAST=192.168.0.255
ONBOOT=yes
METRIC=10
MII_NOT_SUPPORTED=no
USERCTL=yes
</pre>

This next file configures the static routes that we need to communicate to the subnet. Since it has "usb0" in the name, the system will automatically apply these static routes any time that the usb0 interface is configured. (i.e. when you connect the FreeRunner)

<tt>/etc/sysconfig/network-scripts/usb0-routes</tt>:

<pre>
ADDRESS0=192.168.0.200
NETMASK0=255.255.255.0
</pre>

Now we need to restart the network system to pick up the changes.

 service network restart


This didn't work for me (Mandriva 2008.1), giving errors from Shorewall. However, simply using MCC, Network->Sharing Internet Access worked fine. You need to connect Neo when starting it. --[[User:Alih|Alih]] 18:50, 22 September 2008 (UTC)

== SuSE ==

/etc/sysconfig/network/ifcfg-usb0:

 # USB configuration for PDAs (openmoko)
 IPADDR=192.168.0.200
 NETMASK=255.255.255.0
 STARTMODE=onboot

For more information on getting USB networking up using YaST, see [[USB Networking with openSUSE]].

== Fedora ==

=== Option A - Tested with FC9, FC8 & FC5 ===

edit file <tt>/etc/sysconfig/network-scripts/ifcfg-usb0</tt> to look like this:

 # USB configuration for PDAs (openmoko)
 # from <nowiki>http://www.handhelds.org/moin/moin.cgi/UsbNet</nowiki>
 DEVICE=usb0
 BOOTPROTO=none
 IPADDR=192.168.0.200
 NETMASK=255.255.255.0
 ONBOOT=yes

and restart networking service by typing:

 service network restart

if your '''openmoko''' is connected when you restart network you should see system message:

<code>Bringing up interface usb0      [OK]</code>

=== Option B ===

This setup is probably over-complex:

/etc/sysconfig/network-scripts/ifcfg-usb0:

 DEVICE=usb0
 IPADDR=192.168.0.200
 NETMASK=255.255.255.0

/etc/sysconfig/network-scripts/ifup-usb:

 #!/bin/bash
 ./etc/init.d/functions
 cd /etc/sysconfig/network-scripts
 ../network-functions
 [ -f ../network ] && . ../network
 CONFIG=${1}
 need_config ${CONFIG}
 source_config
 NETBITS=`ipcalc -p ${IPADDR} ${NETMASK} | awk -F'=' '{print $2;}'`
 /sbin/ip addr flush dev ${DEVICE} 2>/dev/null
 /sbin/ip link set dev ${DEVICE} up
 /sbin/ip addr add dev ${DEVICE} ${IPADDR}/${NETBITS}
 /sbin/iptables -I POSTROUTING -t nat -j MASQUERADE -s ${IPADDR}/${NETBITS}
 /sbin/sysctl net.ipv4.ip_forward=1
 /sbin/iptables -I FORWARD -s ${IPADDR}/${NETBITS} -j ACCEPT
 /sbin/iptables -I FORWARD -d ${IPADDR}/${NETBITS} -j ACCEPT

Set /etc/sysconfig/network-scripts/ifdown-usb:

 #!/bin/bash
 ./etc/init.d/functions
 cd /etc/sysconfig/network-scripts
 ../network-functions
 [ -f ../network ] && . ../network
 CONFIG=${1}
 need_config ${CONFIG}
 source_config
 NETBITS=`ipcalc -p ${IPADDR} ${NETMASK} | awk -F'=' '{print $2;}'`
 /sbin/iptables -D FORWARD -d ${IPADDR}/${NETBITS} -j ACCEPT
 /sbin/iptables -D FORWARD -s ${IPADDR}/${NETBITS} -j ACCEPT
 /sbin/sysctl net.ipv4.ip_forward=0
 /sbin/iptables -D POSTROUTING -t nat -j MASQUERADE -s ${IPADDR}/${NETBITS}
 /sbin/ip link set dev ${DEVICE} down
 /sbin/ip addr flush dev ${DEVICE} 2>/dev/null

If you are using NetworkManager, restart it and enable the usb device from its menu, otherwise it will disable your connection shortly after you enable it.

 /sbin/service NetworkManager restart

=== Option C - tested on FC8, FC9 and F10 ===

Plug in the usb cable. NetworkManager should detect the phone automatically but you should ignore it.
Open Network Configuration tool (System -> Administration -> Network) and perform following steps:
# Click '''New''' button on top bar
# Click '''Forward'''
# Select OpenMoko from device list
# Click '''Forward'''
# Select 'Statically set IP address:' and enter address: 192.168.0.200, netmask 255.255.255.0 (or use 255.255.255.240 if you want only route ip range 192.168.0.192-192.168.0.207). Leave gateway empty.
# Click '''Forward'''
# Click '''Apply''' to close add dialog
# Select newly added usb0 device from the device list.
# Click '''Edit''' button on top bar
# You might want to remove a tick from 'Activate device when computer starts' check box.
# Click '''Ok''' to close window  dialog.
Save settings and close the window.

Open Firewall Configuration (System -> Administration -> Firewall) and enable masquerading:
# Select '''Masquerading''' from left panel
# Check device(s) which you'd like to share internet connection. Typically eth0 or wlan0.
# Click '''Apply''' and close application

Open terminal and perform (as root user):
# ifdown usb0
# ifup usb0
The first command will remove any existing settings given by the NetworkManager and second command brings the device up with appropriate settings.

Now you should be able to ping e.g. 74.125.39.99 [www.google.com] from OpenMoko. Configure /etc/resolv.conf and you should have full a internet access.

==== Troubleshooting ====
If Network Configuration tool cannot see the the usb0 try to unplug the usb cable for a few seconds and wait until the NetworkManager finds it again.

NetworkManager will assign a new ip address for the OpenMoko if link goes down for a while. You can fix this by issuing '''ifup usb0''' again.

== Red Hat or Similar (tested with Workstation 5) ==

Edit /etc/sysconfig/network-scripts/net.hotplug:

After this command:

<pre>
case $INTERFACE in
# interfaces that are registered after being "up" (?)
</pre>

add

<pre>
usb0)
ifconfig usb0 192.168.0.200 netmask 255.255.255.0
route add 192.168.0.202 usb0
iptables -I INPUT 1 -s 192.168.0.202 -j ACCEPT
iptables -I OUTPUT 1 -s 192.168.0.200 -j ACCEPT
iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
echo 1 > /proc/sys/net/ipv4/ip_forward
exit 0
;;
</pre>

== Gentoo ==

Open /etc/conf.d/net and add:

<pre>
# Neo
config_usb0=( "192.168.0.200 netmask 255.255.255.0" )
routes_usb0=( "192.168.0.202/32 via 192.168.0.200" )
</pre>

Create a new init script:

<pre>
cd /etc/init.d
ln -s net.lo net.usb0
</pre>

=== Manual Configuration ===

Put iptables into use:

<pre>
iptables -I INPUT 1 -s 192.168.0.202 -j ACCEPT
iptables -I OUTPUT 1 -s 192.168.0.200 -j ACCEPT
iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
</pre>

Store them:

 /etc/init.d/iptables save

If you want the routing by default:

 rc-update add iptables default

You must also inform the kernel, to start forwarding.

 echo 1 > /proc/sys/net/ipv4/ip_forward

=== Automatic Configuration ===
One way to automate all this is to create /etc/conf.d/net.usb0 as follows. It sets IP forwarding and the iptables rules all in one go. It removes the iptables rules and disables ip forwarding when the FreeRunner is unplugged.
Therefore the net.usb0 service must be hotpluggable (/etc/rc.conf).

<pre>
preup() {
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -I INPUT 1 -s 192.168.0.202 -j ACCEPT
iptables -I OUTPUT 1 -s 192.168.0.200 -j ACCEPT
iptables -A POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
return 0
}

postdown() {
echo 0 > /proc/sys/net/ipv4/ip_forward
iptables -D INPUT -s 192.168.0.202 -j ACCEPT
iptables -D OUTPUT -s 192.168.0.200 -j ACCEPT
iptables -D POSTROUTING -t nat -j MASQUERADE -s 192.168.0.0/24
return 0
}
</pre>

== Slackware (tested with 12.1) ==

Following is based on [http://www.enricozini.org/2008/tips/autodock-freerunner.html Enrico Zini's solution].

Create a new udev rules file <tt>/etc/udev/rules.d/91-openmoko.rules</tt>:

<pre>
SUBSYSTEM=="net", ACTION=="add", ATTRS{idVendor}=="1457", ATTRS{idProduct}=="5122", RUN+="/sbin/om-usb $env{INTERFACE} start"
SUBSYSTEM=="net", ACTION=="remove", ENV{INTERFACE}=="usb[0-9]", RUN+="/sbin/om-usb $env{INTERFACE} stop"
</pre>

Then create the script <tt>/sbin/om-usb</tt>:

<pre>
#!/bin/sh
INTERFACE=$1
ACTION=$2

# udev fails silently when the script fails, e.g. due to commands not
# being found
PATH=/usr/sbin:/sbin:/usr/bin:/bin

case $ACTION in
'start')
# Put all your setup here
;;
'stop')
# Put all your tear down here
;;
*)
echo "Usage: $0 {start|stop}"
exit 1
;;
esac
</pre>

The <tt>INTERFACE</tt> will be <tt>usb0</tt> in most cases.

== Archlinux ==
Following is based on [http://xenos.altervista.org/blogs/index.php?blog=3&title=openmoko-usb-networking-su-archlinux furester's solution].

Install package [http://aur.archlinux.org/packages.php?ID=20220 openmoko-usb-networking] from AUR:

$ yaourt -S openmoko-usb-networking

= SSH Extras =

Reportedly, the ssh daemon (dropbear 0.49) on the FreeRunner appears to have a bug when sending the exit status back to the client. From time to time you receive an exit status of 255.

To avoid ssh adding a new line for every ssh host-key to your known_hosts you can add the following to the phone section in ~/.ssh/config (or see the snippet at : [[USB Networking#Changing_host_keys]] bellow)

UserKnownHostsFile /dev/null

You might want to use keys to bypass the login prompt too.

== SSH Keys ==

== From desktop to FreeRunner ==

To generate ssh keys for use as a login mechanism type:

 user@host$ ssh-keygen -t rsa

When prompted for a password either hit enter for no password (''not really a good idea'') or enter a password for this key. ssh into the phone and create ~/.ssh:

 root@phone# mkdir ~/.ssh

Then from your desktop copy the '''.pub''' file to the phone.

 user@host$ scp ~/.ssh/id_rsa.pub root@phone:~/.ssh/authorized_keys

You should now be able to ssh directly into the phone without a password prompt using a command like 'ssh root@phone' from the account user@host because the public key in the file user@host:~/.ssh/id_rsa.pub is contained in the list of keys which have access in the file root@phone:~/.ssh/authorized_keys (since scp is used, only one key exists, but you can grant access to the phone from more than one account, for example user@host, user@laptop).

To make ssh login as root by default, add the following lines to ~/.ssh/config:

 Host phone
 User root

Replace ''phone'' with the hostname or ip of your phone. You should now be able to ssh into the phone without having to type ''root@'' every time.

To disable password logins ('''after setting up key access''') edit /etc/init.d/dropbear and change the following line:

 DROPBEAR_EXTRA_ARGS=

to

 DROPBEAR_EXTRA_ARGS="-s"

You will need to restart dropbear for this to take effect.

=== From FreeRunner to Desktop ===

Generate the key:

 dropbearkey -t rsa -f id_rsa

The output will look something like this:

 Will output 1024 bit rsa secret key to 'id_rsa'
 Generating key, this may take a while...
 Public key portion is:
 ssh-rsa AAAAB3Nza[...]
 Fingerprint: md5 ca:e8:f0:b7:f6:7b:c2:b6:b9:71:e4:45:86:a9:ff:b8

Copy and paste the one line (in this example, starting with 'ssh-rsa' onto the end of the host's authorized_keys file (often in ~/.ssh/).

From the phone, ssh with -i:

 ssh -i id_rsa user@host

=== Changing host keys ===

If you reflash, your hosts keys will change.  Try this ~/.ssh/config snippet:

 Host moko
 HostName 192.168.0.202
 StrictHostKeyChecking no
 UserKnownHostsFile /dev/null
 User root

This is suggested because ssh on your desktop may complain if the key matching a certain IP changes (stored in .ssh/known_hosts). Now you have set this, you can issue the following command to connect to your moko (the usual "root@" isn't required as it's set by the user section in the config file) :

 ssh moko

== GUI on desktop through SSH ==

To get the GUI on the FreeRunner onto the desktop via USB, you can use ssh as follows (execute on desktop):

 xhost +
 ssh -l root -X -v 192.168.0.202

Using this, run openmoko-finger-demo for example, and it will open up on the desktop. To get landscape view, just resize the GUI window on the desktop.

If you get an error like this:

<tt>
dbus.exceptions.DBusException: org.freedesktop.DBus.Error.Spawn.ExecFailed: dbus-launch failed to
autolaunch D-Bus session: Autolaunch requested, but X11 support not compiled in.
</tt>

you need to set the DBUS_SESSION_BUS_ADDRESS environment variable to the value on the FreeRunner before launching the process from your desktop.  You can find the value of this variable by using a command such as

 ps auxwwwwe | grep -m 1 DBUS_SESSION_BUS_ADDRESS

Note that you must run that command on the FreeRunner.  Back on your desktop, run the process you want with the ''env'' command like this:

 env DBUS_SESSION_BUS_ADDRESS=''dbus_address'' ''process'' #(isn't the "env" redundant here?)

==Display Remote Applications on FreeRunner==

To get desktop apps to show up on your FreeRunner, first log in:

ssh -l root 192.168.0.202

Then run:

DISPLAY=:0 xhost +192.168.0.200

After this you can close the ssh session. Back on the desktop computer, run:

DISPLAY=openmoko:0 xclock

Note that the xhost command will allow remote applications on 192.168.0.200 to access the X server. It will allow anyone on the desktop machine to access the X server of the neo, including snooping anything you type on it. To disallow remote applications again, run this in the neo:

DISPLAY=:0 xhost -192.168.0.200

== sftp ==
After you get the SSH connection working, it is possible to use Konqueror, Nautilus or another sftp - enabled tool to browse the phone filesystem and deploy the test applications. Just enter sftp://root@192.168.0.202 into address bar.

== sshfs ==
You can use sshfs to mount the phones filesystem into the hosts filesystem. Make sure that fuse-sshfs is installed and that you are allowed to use fuse. Now run:

  sshfs 192.168.0.202:REMOTE_PATH LOCAL_MOUNT_POINT

REMOTE_PATH can now be accessed through LOCAL_PATH.

==Automated setup network and mounting partitions==

See [https://bugs.launchpad.net/ubuntu/+bug/289548 Ubuntu bug report in launchpad].
