QEMU può essere utilizzato in tre diversi modi per eseguire [[OpenMoko/it|OpenMoko]]. A seconda del motivo per cui stai per usare l'emulatore, dovresti scegliere la soluzione più adatta.

*''PC'' - OpenMoko può essere compilato per essere eseguito su una normale macchina i386, a 32 o a 64 bit e probabilmente questa è la via più veloce per eseguire OpenMoko se vuoi una anteprima su come appare e funziona. In questo caso QEMU verrà utilizzato unicamente per isolare l'installazione [[OpenMoko/it|OpenMoko]] dal resto del sistema, o, se non stai usando un sistema UNIX, QEMU fornirà un modo non intrusivo e veloce per ottenere una macchina Linux. Altre informazioni possono essere trovate in [[FAQ/it|FAQ]], [[Getting OpenMoko working on host with Xoo/it|qui]] e [[Getting OpenMoko working on host with Xephyr/it|qui]].

*''Integrator/CP'' - Questa è la macchina ARM-based di default che QEMU utilizza. Questo metodo va utilizzato con MACHINE="qemuarm" ed è sufficiente per eseguire l'immagine rootfs originale di OpenMoko, nessun componente hardware tra [[:Category:Neo1973 Hardware/it | Neo1973 Hardware]] verrà emulato, ad eccezione della CPU. Altre informazioni in [[FAQ/it#Q:_Is_there_an_emulator_available_for_OpenMoko.3F|FAQ]].

*''Neo1973'' - Nei repositories OpenMoko è disponibile una versione di QEMU in grado di emulare la maggior parte dell'hardware [[Neo1973/it|Neo1973]] ma non tutto per ora. Quando il progetto sarà più maturo verrà integrato nel ramo di sviluppo principale di QEMU.

== Emulazione Neo1973 ==

Questo metodo permette (ovviamente) di eseguire l'immagine rootfs originale di OpenMoko, dovrebbe essere anche in grado di eseguire l'u-boot originale e le immagini del kernel, le stesse che usa un Neo1973 reale. Altra differenza rispetto al metodo Integrator/CP, è che in questo modo possiamo ottenere una risoluzione corretta dello schermo, alcune (false) letture della batteria e altre cose simili. Attualmente, le parti mancanti all'emulatore sono: [[Hardware:AGPS/it|AGPS]] e [[Bluetooth/it|Bluetooth]] - il lavoro su questa parti procede. Anche con queste parti mancanti, QEMU dovrebbe fornire un aiuto sostanziale agli sviluppatori nel debugging del kernel e di u-boot.

QEMU '''*non*''' può essere utilizzato, e probabilmente nemmeno altri emulatori possono, per misurare le prestazioni generali di OpenMoko. L'esecuzione del codice in QEMU avviene alla massima velocità che il computer host è in grado di fornire, con un overhead dovuto alla necessità di tradurre il codice. Questo overhead non è uniforme per tutte le differenti istruzioni, quindi se il tuo Neo virtuale riporta circa 100 BogoMIPS (che è la velocità di un Neo reale), azioni differenti eseguite dall'emulatore potrebbero essere portate a termine a velocità diverse. Nella maggior parte dei casi, il Neo virtuale eseguirà più velocemente rispetto ad uno reale (le operazioni legate all'audio potrebbero essere un'eccezione).

=== Quale hardware è supportato ===

Approssimativamente, questa è la situazione di ogni componente che necessita emulazione, seguendo la pagina [[:Category:Neo1973 Hardware/it | Neo1973 Hardware]].

{|
! Hardware !! Stato !! Note utilizzo
|- style="background-color:#eeeedd;"
! colspan="3"|Processore S3C2410A
|-
|ARM920T core || Funziona || Presente in QEMU.
|-
|Basic guts || Funziona || Comprende l'interfaccia GPIO, DMA, Interrupt Controller, Timers, NAND controller, MMC/SD host, [[I2C/it|I2C]] e IIS interfaces, Memory & Clock & Power management controllers, RAM.
|-
|Serial ports || Funziona || Usa "-serial" switch (potrebbe essere specificato diverse volte) per dire a QEMU dove mandare i serial input/output. Il modulo GSM andrà connesso a UART0.
|-
|RTC || Funziona || All'avvio QEMU verrà caricato con l'ora/data corrente - il [[kernel/it|kernel]] Neo1973 attualmente non lo usa come sorgente.
|-
|SPI || Funziona || Il kernel guest può utilizzarlo sia tramite interfaccia SPI che tramite raw GPIO bitbanging.
|-
|LCD || Funziona || Il LCD virtuale verrà visualizzato come in una finestra QEMU se "-nographic" non viene specificato.
|-
|ADC || Funziona || Gli eveti del mouse nella finestra QEMU, generano quello che gli eventi del touchscreen genererebbero su un Neo1973 e sono rimandati al sistema guest attraverso il on-chip ADC.
|-
|OHCI USB || Funziona || Compresa nel ramo principale di QEMU. Usare "-usb" per abilitare il controller e "usb_add" nel monitor QEMU per connettere nuovi device USB, virtuali o meno.
|-
|Slave USB || Funziona || Linux dummy HCD, unito alle API aggiuntive del filesystem, viene usato per fare in modo che il Neo virtuale appaia come se fosse realmente connesso all'host. Vedere [[#Setting up USB connection/it|Configurare connessioni USB]]. (Sperimentale)
|-
|Watchdog || Funziona || Questa è una delle periferiche meno importanti in S3C2410. Viene comunque usata da Linux per il riavvio della scheda.
|- style="background-color:#eeeedd;"
! colspan="3"| Periferiche bus [[I2C/it|I2C]]
|-
|[[PCF50606/it|PCF50606]] || Funziona || (Chiamato anche PMU) Falsifica la carica della batteria (fissa ad 88%), il tasto POWER, etc. Contiene anche RTC, non utilizzato da Linux.
|-
|[[LM4857/it|LM4857]] || Funziona
|-
|[[WM8753L/it|WM8753L]] || Funziona || Il CODEC è connesso anche alla porta IIS della CPU. Le [[Neo1973 Audio Subsystem/it|funzionalità audio]] di base sono supportate - vedere la documentazione QEMU per informazioni sul funzionamento dell'audio nell'emulatore. Il controllo del volume non funziona.
|- style="background-color:#eeeedd;"
! colspan="3"|Altre periferiche
|-
|NAND Flash || Funziona || Comunque, per alcune parti non è confermata la completa compatibilità con l'hardware reale a causa della sua mancanza. Usare "-mtdblock flashimagefilenamehere" per indicare l'immagine a QEMU. Il file dovrebbe essere grande almeno 69206016 bytes.
|-
|JBT6K74-AS(PI) || Funziona || (Chiamato anche LCM) Cablato sul canale SPI 1
|-
|Buttons || Funziona || Il tasto "enter" corrisponde al tasto AUX, "spazio" al tasto POWER. Cablato su GPIO e PCF50606.
|-
|SD card || Funziona || Questa parte è già compresa in QEMU. Usare "-sd cardimagegoeshere" per indicare l'immagine a QEMU. Si può anche utilizzare il monitor QEMU per i media rimovibili. Il lettore funziona ma a volte il controller dell'host ottiene errori nella dimensione dei blocchi se sottoposto a pesanti operazioni I/O, probabilmente a causa dei driver nel kernel. Le operazioni DMA non sono testate.
|-
|Bluetooth
|style="background-color:#ffffcc;"|Funziona
|Un HCI Bluetooth generico (come il chip BlueCore4) è connesso all'hub USB interno (come il Delta DBFM dongle). Attualmente QEMU non emula altri device bluetooth, quindi si comporta come unico device nella piconet, i.e. non è molto utile. Potrà essere emulata una tastiera Bluetooth. Un dispositivo Bluetooth può comunque essere connesso all'emulatore (vedere la documentazione QEMU relativa all'USB).
|-
|[[GSM/it|GSM]] || Funziona || Un modem virtuale è connesso a UART0 e comprende un sottoinsieme (attualmente abbastanza limitato) di comandi AT. Ultimamente dovrebbe supportare la maggior parte delle funzionalità (comandi AT base, connessioni GPRS, chiamate e SMS). In questo modo tutta la parte del "sottosistema telefono" (CALYPSO, TWL3014, TRF6151) non ha bisogno di emulazione. C'è la possibilità di connettere un reale modem GSM alla porta seriale di QEMU.
|-
|[[Hardware:AGPS/it|AGPS]]
|style="background-color:#ffcccc;"|Da fare
|Ci sono alcune ovvie difficoltà nell'emularlo ma si spera di riuscirci impostando il sistema ospite con delle coordinate fisse quando il chip sarà più conosciuto. Anche in questo caso, un chip reale può essere connesso alla porta seriale di QEMU,.
|}

Lo sviluppo attuale è centrato sulla compatibilità [[:Category:Neo1973_Hardware/it#GTA01Bv4 | GTA01Bv4]];
[[:Category:Neo1973_Hardware/it#GTA01Bv3 | versioni precedenti]] possono essere emulate se necessario. La differenza tra le revisioni hardware attualmente si manifesta solo nel GPIO. L'emulazione hardware è implementata in modo pulito, usando le specifiche ufficiali dove possibile.

== Come renderlo funzionante ==

=== Usando MokoMakefile ===

Questa è probabilmente il modo più semplice per ottenere qemu-neo1973 visto che non sono necessari i processi di compilazione ed installazione. Vedere [[MokoMakefile/it#QEMU|MokoMakefile]] per maggiori dettagli. (Notare che la compilazione completa di MokoMakefile dura diverse ore, a volte giorni, mentre questa procedura circa 15 minuti).

=== Configurazione manuale ===

Per ottenere gli ultimi sorgenti dell'emulatore, dovrai eseguire un comando simile al seguente:
<pre>
$ svn checkout https://svn.openmoko.org/trunk/src/host/qemu-neo1973
$ cd qemu-neo1973
</pre>
Ora configureremo l'emulatore (Vedere i [[#Requirements|requisiti]] qui sotto):
<pre>
$ ./configure --target-list=arm-softmmu  # GCC 3.x will be required, see --cc=
$ make
</pre>
Per vedere le possibili opzioni di configurazione dello script, basta aggiungere "--help".
Ora dovresti avere un emulatore funzionante chiamato "arm-softmmu/qemu-system-arm". Per eseguire OpenMoko avrai bisogno di installare OpenMoko sul tuo telefono virtuale, attualmente è completamente privo di software. Ci son diversi modi tra cui scegliere, probabilmente l'opzione migliore è fare esattamente quello che fanno i produttori di Neo1973 prima di spedire il dispositivo all'utente finale. Questo processo è descritto in [[Bootloader/it|Bootloader]], [[Kernel/it|Kernel]], [[NAND bad blocks/it|NAND bad blocks]] e [[Devirginator/it|Devirginator]] ma non serve conoscere i dettagli. Vengono forniti due script per generare il firmware del telefono, nel modo più realistico possibile.
Eseguire:
<pre>$ openmoko/download.sh</pre>
which will look up the list of latest available OpenMoko snapshot builds from buildhost.openmoko.org and choose the most recent [[u-boot]], Kernel, and root filesystem images, and download the images (unless they are already found in the openmoko/ directory). These binaries will be used by the next command:
<pre>$ openmoko/flash.sh</pre>
which runs the emulator, loads u-boot into it and then uses u-boot's capability to program the Flash memory to install all the necessary parts of the system into the virtual Flash. It will also set up all the bootloading process including a boot menu (ENTER is [AUX] and SPACE is [POWER]), splash, u-boot environment and some default kernel parameters. If everything goes OK, the script should print a command which you can use to start using the emulator.

QEMU has '''*tons*''' of commandline switches and things that can be configured. You can look them up in [http://www.qemu.org/user-doc.html QEMU user docs]. You will probably want to use the "-snapshot" switch, among other ones. Saving and restoring emulation state at any point (unrelated to "-snapshot") should work as per QEMU user docs too.

=== Pre-built binaries ===

Win32 binaries shipped with firmware can be downloaded from [http://mdk.linux.org.tw/~jserv/openmoko/openmoko-emulator-win32-bin-20070625.zip openmoko-emulator-win32-bin-20070625.zip]. Tested on MS Windows XP and Vista Business.

== Requirements ==

This QEMU tree has only been tested on GNU/Linux. To get graphical (not counting VNC) and/or audio output from the emulator you will need either SDL or Cocoa installed on your computer. To enable audio, see the available switches to the ./configure script.

The scripts that sit in openmoko/ require lynx, wget, python and most GNU base utilities installed in standard locations. If you are using the flash.sh script, you will need to install the netpbm package to get the png conversion tools.

All of the build-time and run-time requirements listed in [http://www.qemu.org/user-doc.html QEMU documentation] apply. This includes zlib, etc. On distributions that use binary packages, remember that you need the packages ending in '''-dev''' or '''-devel'''.

== QEMU and GNU debugger ==

QEMU lets you debug operating system kernels and bootloaders like you debug all other programs. To do this you will need a debugger that speaks the GDB remote debugging protocol - [http://sourceware.org/gdb/ GDB] is the obvious choice. Some cross toolchains come with GDB already set up. Otherwise building cross-GDB yourself is quick and easy (compared to building binutils and cross-gcc).

To debug u-boot, load the file "u-boot" into gdb (not "u-boot.bin") that is produced by "make" when building u-boot. To debug a Linux kernel, load the file "vmlinux" from the main source directory into gdb. These files are in ELF format and contain all the symbol information and are not stripped of debugging data until you run "strip" on them, unlike "u-boot.bin" and "Image"/"zImage"/"uImage". Next, tell QEMU to enable the gdbserver by appending the "-s" switch or issuing "gdbserver" in the monitor. Use the command <pre>(gdb) target remote localhost:1234</pre> to make a connection to the emulator. From there you should be able to use all the usual GDB commands, including stepping instructions, setting breakpoints, watchpoints, inspecting stack, variables, registers and more. If gdb is running in the same directory from which it grabbed the ELF executable, the "edit" command should work so you can jump right to the source line which is executing.

== Setting up USB connection ==

It is possible (although not very straight forward, probably about the complexity of tun-tap networking) to connect the virtual, emulated Neo1973 to the Linux PC on which the emulator is running, and work with it as if a real Neo1973 was plugged into the computer's USB port, but no twiddling with cables is needed. If you're testing your applications on the Neo, it may be worth setting up this kind of connection because it lets you enable normal [[USB_Networking|networking between the PC and the phone and ssh into it]] (which is much more comfortable than typing commands into the OpenMoko's terminal emulator via on-screen keyboard). Here's what you will need in order to get this working:

A Linux host with a 2.6 series kernel. The following drivers compiled-in or in modules: dummy_hcd, gadgetfs, usbnet, cdc_ether. Note that you need root access to perform most actions described here. Here's how to enable them in menuconfig.

Find and enable '''Device Drivers''' -> '''USB support''' -> '''USB Gadget Support''' -> '''Support for USB Gadgets'''

Find '''Device Drivers''' -> '''USB support''' -> '''USB Gadget Support''' -> '''USB Peripheral Controller''' and set it to '''Dummy HCD (DEVELOPMENT)'''

Find and enable '''Device Drivers''' -> '''USB support''' -> '''USB Gadget Support''' -> '''Gadget Filesystem (EXPERIMENTAL)''' (this one is good to have as a module)

Find and enable '''Device Drivers''' -> '''USB support''' -> '''USB Network Adapters''' -> '''Multi-purpose USB Networking Framework'''

Find and enable '''Device Drivers''' -> '''USB support''' -> '''USB Network Adapters''' -> '''CDC Ethernet support (smart devices such as cable modems)'''

These last two drivers are the same [[Getting Started with your Neo1973#By using Ethernet emulation over a USB cable|drivers that you need to work with a real Neo over USB network]]. After you've built the drivers, make sure that the copy of kernel headers in /usr/include/linux is up to date. In particular the file /usr/include/linux/usb_gadgetfs.h needs to be present and if your distribution came with headers older than 2.6.18 or so, then you need tell the package manager to update them, or you can do that manually with
<pre> # cp -a /usr/src/linux/include/linux/* /usr/include/linux/</pre>
(assuming that your kernel sources are in /usr/src/linux). It is important that this is done before building qemu because the build system checks if these headers are functional and in case they aren't found it will disable the USB Slave functionality.

After building qemu and before running it, make sure that the modules are loaded into the kernel. I found it useful to load gadgetfs with the following command:
<pre> # modprobe gadgetfs default_uid=1000  # assuming my User ID is 1000</pre>
and added the following line to my /etc/fstab:
<pre>gadget         /dev/gadget    gadgetfs   noauto,user,group         0   0</pre>
Make sure that the mountpoint /dev/gadget exists:
<pre> # mkdir -p /dev/gadget</pre>
After that the rest of the procedure can be performed from your regular user account. Mounting gadgetfs is done with:
<pre> $ mount /dev/gadget</pre>
The "default_uid" parameter changes the ownership on all files under /dev/gadget to your own and since the files there are created and destroyed dynamically, there's no easy way to have that performed by ''udev''. Now running qemu as you usually do but appending "-usb -usbgadget" should enable the USB Slave functionality. The qemu monitor commands "info usbslave" and "usb_add gadget" will be useful. The former instruction asks the OS running under the emulator (OpenMoko) to describe its slave features (that's what ''lsusb'' does after a Neo1973 is connected to a PC). You can see the available USB configurations in this command's output. Since gadgetfs allows only one configuration, we will need to choose the desired configuration - most device have only one such configuration, in which case you can use just "usb_add gadget" to connect to host; CDC ethernet devices however usually include a second configuration for RNDIS networking (i.e. Ms Windows compatibility) and so does OpenMoko when using the g_ether driver. Hence, to get this right, wait for OpenMoko to fully boot up and execute the following in QEMU monitor:
<pre>
QEMU 0.9.0 monitor - type 'help' for more information
(qemu) info usbslave 
USB2.2 device 1457:5122:
Manufacturer: Linux 2.6.20.7-moko8/s3c2410_udc
Product: RNDIS/Ethernet Gadget
Configuration 0: RNDIS
Configuration 1: CDC Ethernet
(qemu) 
(qemu) usb_add gadget:1
</pre>
The "1" in "usb_add gadget:N" is the number of the USB configuration that we want to use. If everything went correctly - you can check that in dmesg - you should now have a new network interface called ''usb0'' on the PC, through which you can talk to the OpenMoko running in QEMU:
<pre>
 $ dmesg | tail
<6>gadgetfs: bound to dummy_udc driver
<7>hub 3-0:1.0: debounce: port 1: total 100ms stable 100ms status 0x101
<6>usb 3-1: new high speed USB device using dummy_hcd and address 3
<6>gadgetfs: connected
<7>usb 3-1: default language 0x0409
<7>usb 3-1: new device strings: Mfr=1, Product=2, SerialNumber=0
<6>usb 3-1: Product: RNDIS/Ethernet Gadget
<6>usb 3-1: Manufacturer: Linux 2.6.20.7-moko8/s3c2410_udc
<6>usb 3-1: configuration #1 chosen from 1 choice
<7>usb 3-1: adding 3-1:1.0 (config #1, interface 0)
<7>usb 3-1:1.0: uevent
<7>cdc_ether 3-1:1.0: usb_probe_interface - got id
<7>cdc_ether 3-1:1.0: status ep3in, 16 bytes period 14
<7>usb 3-1: adding 3-1:1.1 (config #1, interface 1)
<7>usb 3-1:1.1: uevent
 $ su -
Password:
 # tail /var/log/everything/current
May  8 19:25:32 [kernel] gadgetfs: connected
May  8 19:25:32 [kernel] gadgetfs: disconnected
May  8 19:25:32 [kernel] gadgetfs: configuration #1
May  8 19:25:32 [kernel] usb0: register 'cdc_ether' at usb-dummy_hcd-1, CDC Ethernet Device, 52:e7:eb:76:0a:d0
 # lsusb -vvv
Bus 003 Device 003: ID 1457:5122  
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            2 Communications
  bDeviceSubClass         0 
  bDeviceProtocol         0 
  bMaxPacketSize0        64
  idVendor           0x1457 
  idProduct          0x5122 
  bcdDevice            2.12
  iManufacturer           1 Linux 2.6.20.7-moko8/s3c2410_udc
  iProduct                2 RNDIS/Ethernet Gadget
  iSerial                 0 
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength           80
    bNumInterfaces          2
    bConfigurationValue     1
    iConfiguration          7 CDC Ethernet
    bmAttributes         0xc0
      Self Powered
    MaxPower                0mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass         2 Communications
      bInterfaceSubClass      6 Ethernet Networking
      bInterfaceProtocol      0 
      iInterface              5 CDC Communications Control
      CDC Header:
        bcdCDC               1.10
      CDC Union:
        bMasterInterface        0
        bSlaveInterface         1 
      CDC Ethernet:
        iMacAddress                      3 52E7EB760AD0
        bmEthernetStatistics    0x00000000
        wMaxSegmentSize               1514
        wNumberMCFilters            0x0000
        bNumberPowerFilters              0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0010  1x 16 bytes
        bInterval              14
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           0
      bInterfaceClass        10 Data
      bInterfaceSubClass      0 Unused
      bInterfaceProtocol      0 
      iInterface              0 
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       1
      bNumEndpoints           2
      bInterfaceClass        10 Data
      bInterfaceSubClass      0 Unused
      bInterfaceProtocol      0 
      iInterface              4 Ethernet Data
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x02  EP 2 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
Device Qualifier (for other device speed):
  bLength                10
  bDescriptorType         6
  bcdUSB               2.00
  bDeviceClass            2 Communications
  bDeviceSubClass         0 
  bDeviceProtocol         0 
  bMaxPacketSize0        64
  bNumConfigurations      1

 # ifconfig usb0 inet 192.168.0.200 netmask 255.255.255.0
 # exit
 $ ssh root@192.168.0.202
The authenticity of host '192.168.0.202 (192.168.0.202)' can't be established.
RSA key fingerprint is de:21:87:93:52:1c:6b:c7:69:29:6c:af:66:50:02:02.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.0.202' (RSA) to the list of known hosts.
root@192.168.0.202's password: 
root@fic-gta01:~$ uname -a
Linux fic-gta01 2.6.20.7-moko8 #1 PREEMPT Wed Apr 25 11:13:52 UTC 2007 armv4tl unknown
