script to Auto connect to Open wirelss 802.11 AP's
====wifiweasel====
wifiweasel v1
once run this script takes control of the wireless interface
detects and connects to strongest open wifi AP in the vicinity
and checks connectivity every X seconds if connection fails the
whole proccess repeats itself, requires timeout script below
*needs to be tested with multiple AP's might have a iwconfig essid glitch
<pre> 
#!/bin/sh
   #####################
###########################
#/var/wifi/hacker/kd8ikt###
# OMG i'm programming now!#
###########################
###we.trekbeyond.org#######
  #####################
        #KISS#

# CONFIG
#######interface################
IFACE=eth0 
#Dhcp_timeout
DHCP=4
#check connectivity every X sec
X=30
#
# /CONFIG
################################
#### Scan Funk ####
Func_iwlist_open () {
iwlist $IFACE scanning | awk -F '[ :=]+' '/(ESS|Freq|Qual)/{ printf $3" " } /Encr/{ print $4 }' \
    | sort -k4 -k3nr |grep -m1 off \
|awk '{print $1}' > /tmp/weasel
sed /\"/s/\"//g /tmp/weasel > /tmp/ESSID
}
#### iface up Funk ######## 
Func_ifconfig_up () {
iwconfig $IFACE essid `cat /tmp/ESSID` 
}
#### iface down Funk #####
Func_ifconfig_down () {
killall udhcpc 
ifconfig $IFACE down	
}
#### Conn Funk #####
Func_chk_net ()	{  
ping -w 2 -c1  $dns 
if [ $=0 ];then ERROR=0; echo; echo Online!  go download some pr0n echo; ;sleep $X; Func_chk_net ; 
fi  #W00T  
if [ $=1 ] ; then ERROR=1 ;echo ;echo FAIL!\ 
... Searching ; Func_Main ;
fi 
 }
#### Main Funk #########
Func_MAIN () { while [ ERROR=1 ] ; do
Func_ifconfig_down ;
Func_iwlist_open Func_ifconfig_up ;
timeout $DHCP udhcpc $IFACE |grep adding|awk '{print $3}' > /tmp/dns 
export dns=`cat /etc/resolv.conf |grep name |awk '{print $2}'`
Func_chk_net ;
Func_MAIN ;
done; 
} 
#### MAIN #### 
Func_ifconfig_down ;
Func_iwlist_open Func_ifconfig_up  ; 
udhcpc $IFACE ; 
export dns=`cat /etc/resolv.conf |grep name |awk '{print $2}'`
Func_chk_net ; 
Func_MAIN ;
echo This is the end my only friend the end
Done; #actually i dont think it ever ends
#####################EOF##################
</pre>

====timeout====
added timout script to keep udhcpc from hanging everything
cause we all know dhcp doesnt take 60 sec if its not in by 2-3 sec 
guess what? you aint getting an ip (range issues/mac filtering etc)

INSTALL /usr/bin/timeout

<pre>

#Newsgroups: comp.unix.admin,comp.unix.solaris,comp.unix.shell
#From: gwc@root.co.uk (Geoff Clare)
#Subject: Re: timeout -t <sec> <unix command> (Re: How to give rsh a shorter timeout?)
#Message-ID: <EoBxrs.223@root.co.uk>
#Date: Fri, 13 Feb 1998 18:23:52 GMT

#
# Conversion to bash v2 syntax done by Chet Ramey <chet@po.cwru.edu
# UNTESTED
#

prog=${0##*/}
usage="usage: $prog [-signal] [timeout] [:interval] [+delay] [--] <command>"

SIG=-TERM       # default signal sent to the process when the timer expires
timeout=60      # default timeout
interval=15     # default interval between checks if the process is still alive
delay=2         # default delay between posting the given signal and
                # destroying the process (kill -KILL)

while :
do
        case $1 in
        --)     shift; break ;;
        -*)     SIG=$1 ;;
        [0-9]*) timeout=$1 ;;
        :*)     EXPR='..\(.*\)' ; interval=`expr x"$1" : "$EXPR"` ;;
        +*)     EXPR='..\(.*\)' ; delay=`expr x"$1" : "$EXPR"` ;;
        *)      break ;;
        esac
        shift
done

case $# in
0)      echo "$prog: $usage" >&2 ; exit 2 ;;
esac

(
        for t in $timeout $delay
        do
                while (( $t > $interval ))
                do
                        sleep $interval
                        kill -0 $$ || exit
                        t=$(( $t - $interval ))
                done
                sleep $t
                kill $SIG $$ && kill -0 $$ || exit
                SIG=-KILL
        done
) 2> /dev/null &

exec "$@"

</pre>

=sandbox=
====iwscan perl====
<pre>
#!/usr/bin/perl
# Tim Osburn - tim@osburn.com
#
# install perl

$iwlist = "/sbin/iwlist eth0 scanning";

open scan, "$iwlist |";
while (<scan>) {
  if (/^\s+Cell (\S+) - Address: (\S+)/) {
    $CELL=$1;
    $ADDRESS=$2;
    # print "$1 $2";
    $INLOOP=1;
    }
  if (/^\s+ESSID:(\S+)/) {
    $ESSID=$1;
    print " $1";
    }
  if (/^\s+Frequency:\S+ \S+ \(Channel (\S+)\)/) {
    $CHAN=$1;
    print " $1";
    }
  if (/^\s+Quality=\S+\s+Signal level=(\S+).*/) {
    $SIGNAL=$1;
    print " $1";
    }
  if (/^\s+Encryption key:(\S+)/) {
    $ENCRYPTION=$1;
    print " $1\n";
    }
  }
close scan;
</pre>
produces output in the form of
"essid"  channel  signal_strength  encryption_status

<br> "ESSID_NAME1" 1 -82 on
<br> "ESSID_NAME2" 1 -49 off

[[category:Technical ]]
[[category:GTA02 Hardware]]
